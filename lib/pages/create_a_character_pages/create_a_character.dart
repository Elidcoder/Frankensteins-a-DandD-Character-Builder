// External Imports
import "package:flutter/material.dart";
import "dart:math";

// Project Imports
import "spell_handling.dart";
import "../../main.dart";
import "../../content_classes/all_content_classes.dart";
import "creation_tabs.dart";
import "../../utils/style_utils.dart";
import "finishing_up_tab.dart";

/* Notifier for when settings changes colour to rebuild. */
final ValueNotifier<int> tabRebuildNotifier = ValueNotifier<int>(0);

class CreateACharacter extends StatefulWidget {
  const CreateACharacter({super.key});

  @override
  MainCreateCharacter createState() => MainCreateCharacter();
}

class MainCreateCharacter extends State<CreateACharacter>
    with AutomaticKeepAliveClientMixin {
  @override
  bool get wantKeepAlive => true;

  // Text editing controllers
  /// Basics 
  TextEditingController nameEnterController = TextEditingController();
  TextEditingController playerNameEnterController = TextEditingController();
  TextEditingController genderEnterController = TextEditingController();
  /// Character group
  TextEditingController groupEnterController = TextEditingController();
  
  static const List<String> tabLabels = [
    "Basics",
    "Race",
    "Class",
    "Background",
    "Ability Scores",
    "ASIs and Feats",
    "Spells",
    "Equipment",
    "Backstory",
    "Finishing up"
  ];

  static const List<String> abilityScores = [
    "Strength",
    "Dexterity",
    "Constitution",
    "Intelligence",
    "Wisdom",
    "Charisma"
  ];

  
  // Stores the widgets generated by class levels
  List<Widget> widgetsInPlay = []; 
  String? levellingMethod;
  String? characterLevel = "1";
  int pointsRemaining = 27;
  List<String> coinTypesSelected = ["Gold"];
  // TODO: Moved featFilters and filteredFeats to AsiFeatTab where they're actually used

  int numberOfRemainingFeatOrASIs = 0;
  bool remainingAsi = false;
  

  // FUTUREPLAN(Implement an experience levelling alternative using these)
  String enteredExperience = "";
  TextEditingController experienceEnterController = TextEditingController();
  
  // FUTUREPLAN(Implement a better skill proficiency section using skillProficienciesMap and adding a second field then delete this)
  List<String> skillProficiencies = [];

  Character character = Character.createDefault();

  int get charLevel {
    return int.parse(characterLevel ?? "1");
  }

  bool get canCreateCharacter {
    return (pointsRemaining == 0 &&
      numberOfRemainingFeatOrASIs == 0 &&
      !remainingAsi &&
      charLevel <= character.classList.length &&
      character.chosenAllEqipment && 
      character.chosenAllSpells
    );
  }

  @override
  Widget build(
    BuildContext context,
  ) {
    super.build(context);

    return ValueListenableBuilder<int>(
      valueListenable: tabRebuildNotifier,
      builder: (context, value, child) {return DefaultTabController(
      length: tabLabels.length,
      child: Scaffold(
        backgroundColor: InitialTop.colourScheme.backgroundColour,
        appBar: AppBar(
          foregroundColor: InitialTop.colourScheme.textColour,
          backgroundColor: InitialTop.colourScheme.backingColour,
          title: const Center(
            child: Text(
              textAlign: TextAlign.center,
              "Create a character",
              style: TextStyle(fontSize: 40, fontWeight: FontWeight.w700),
            ),
          ),
          bottom: TabBar(
            tabs: tabLabels.map((e) => StyleUtils.tabLabel(e)).toList(),
            indicatorColor: InitialTop.colourScheme.textColour,
          ),
        ),
        body: TabBarView(children: [
          // Basics Tab
          BasicsTab(
            character: character,
            levellingMethod: levellingMethod,
            characterLevel: characterLevel,
            nameEnterController: nameEnterController,
            playerNameEnterController: playerNameEnterController,
            genderEnterController: genderEnterController,
            experienceEnterController: experienceEnterController,
            numberOfRemainingFeatOrASIs: numberOfRemainingFeatOrASIs,
            onCharacterChanged: () {
              setState(() {});
            },
            onLevellingMethodChanged: (newMethod) {
              setState(() {
                levellingMethod = newMethod;
              });
            },
            onCharacterLevelChanged: (newLevel) {
              setState(() {
                characterLevel = newLevel;
              });
            },
            onNumberOfRemainingFeatOrASIsChanged: (newCount) {
              setState(() {
                numberOfRemainingFeatOrASIs = newCount;
              });
            },
          ),
          
          // Race Tab
          RaceTab(
            character: character,
            onCharacterChanged: () {
              setState(() {});
            },
          ),

          // Class Tab
          DefaultTabController(
            length: 2,
            child: Scaffold(
              backgroundColor: InitialTop.colourScheme.backgroundColour,
              floatingActionButton: FloatingActionButton(
                tooltip: "Increase character level by 1",
                foregroundColor: InitialTop.colourScheme.textColour,
                backgroundColor: (charLevel < 20)
                  ? InitialTop.colourScheme.backingColour
                  : unavailableColor,
                onPressed: () {
                  if (charLevel < 20) {
                    setState(() {
                      characterLevel = "${charLevel + 1}";
                    });
                  }
                },
                child: const Icon(Icons.exposure_plus_1),
              ),
              appBar: AppBar(
                foregroundColor: InitialTop.colourScheme.textColour,
                backgroundColor: InitialTop.colourScheme.backingColour,

                /* Remove default back button */
                leading: IconButton(
                  icon: Icon(Icons.arrow_back, color: InitialTop.colourScheme.backingColour),
                  onPressed: () {},
                ),

                
                /* Class choices available and taken to/by the user. */
                title: Column(
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    Center(
                      child: StyleUtils.buildStyledMediumTextBox(
                        text: "${charLevel - character.classLevels.reduce(sum)} class level(s) unselected",
                        color: InitialTop.colourScheme.textColour)
                      ),
                    character.classList.isNotEmpty
                      ? StyleUtils.buildStyledSmallTextBox(
                        text: "Levels in Classes: ${CLASSLIST.asMap().entries.where((entry) => character.classLevels[entry.key] != 0).map((entry) => "${entry.value.name} - ${character.classLevels[entry.key]}").join(", ")}",
                        color: InitialTop.colourScheme.textColour)                        
                      :  StyleUtils.buildStyledSmallTextBox(
                        text: "No levels selected in any class",
                        color: InitialTop.colourScheme.textColour),
                    const SizedBox(height: 3)
                  ],
                ),
                bottom: TabBar(
                  tabs: [
                    StyleUtils.tabLabel("Choose your classes"),
                    StyleUtils.tabLabel("Make your selections for each level in your class")
                  ],
                  indicatorColor: InitialTop.colourScheme.textColour,
                ),
              ),
              body: TabBarView(children: [
                /* Generates a set of cards (1 for each class) with buttons allowing 
                 * users to view and select each class */
                Container(
                    padding: const EdgeInsets.only(top: 17),
                    child: SingleChildScrollView(
                      scrollDirection: Axis.vertical,
                      child: Wrap(
                        spacing: 8.0,
                        runSpacing: 8.0,
                        alignment: WrapAlignment.center,
                        children: List.generate(CLASSLIST.length, (index) {
                          return Container(
                            width: 240,
                            height: 175,
                            decoration: BoxDecoration(
                              color: InitialTop.colourScheme.backingColour,
                              border: Border.all(color: Colors.black, width: 1.8),
                              borderRadius: const BorderRadius.all(Radius.circular(5)),
                            ),
                            child: Column(
                              children: [
                                /* Information about the class */
                                Text(CLASSLIST[index].name,
                                  style: TextStyle(
                                    fontSize: 30,
                                    fontWeight: FontWeight.w700,
                                    color: InitialTop.colourScheme.textColour)),
                                StyleUtils.buildStyledTinyTextBox(
                                  text: "Class type: ${CLASSLIST[index].classType}", 
                                  color: InitialTop.colourScheme.textColour
                                ),
                                StyleUtils.buildStyledTinyTextBox(
                                  text: (["Martial", "Third Caster"].contains(CLASSLIST[index].classType))
                                    ? "Main ability: ${CLASSLIST[index].mainOrSpellcastingAbility}"
                                    : "Spellcasting ability: ${CLASSLIST[index].mainOrSpellcastingAbility}", 
                                  color: InitialTop.colourScheme.textColour
                                ),
                                StyleUtils.buildStyledTinyTextBox(
                                  text: "Hit die: D${CLASSLIST[index].maxHitDiceRoll}", 
                                  color: InitialTop.colourScheme.textColour
                                ),
                                StyleUtils.buildStyledTinyTextBox(
                                  text: "Saves: ${CLASSLIST[index].savingThrowProficiencies.join(", ")}", 
                                  color: InitialTop.colourScheme.textColour
                                ),
                                const SizedBox(height: 7),

                                /* Button to take a level in the class */
                                ElevatedButton(
                                  style: OutlinedButton.styleFrom(
                                    backgroundColor: (charLevel <= character.classLevels.reduce(sum) || (!multiclassingPossible(CLASSLIST[index])))
                                      ? unavailableColor
                                      : InitialTop.colourScheme.backingColour,
                                    shape: const RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(4))),
                                    side: const BorderSide(width: 3, color: positiveColor)
                                  ),
                                  onPressed: () {
                                    setState(() {

                                      // Check if the character can level up in the class
                                      if (charLevel > character.classList.length && (multiclassingPossible(CLASSLIST[index]))) {
                                        character.classList.add(CLASSLIST[index].name);

                                        if (CLASSLIST[index].gainAtEachLevel[character.classLevels[index]]
                                                .where((element) => element[0] == "Choice").isEmpty) {
                                          widgetsInPlay.add(StyleUtils.buildStyledSmallTextBox(text: "No choices needed for ${CLASSLIST[index].name} level ${CLASSLIST[index].gainAtEachLevel[character.classLevels[index]][0][1]}"));
                                        } else {
                                          widgetsInPlay.add(StyleUtils.buildStyledMediumTextBox(text: "${CLASSLIST[index].name} Level ${CLASSLIST[index].gainAtEachLevel[character.classLevels[index]][0][1]} choice(s):"));
                                        }

                                        for (List<dynamic> x in CLASSLIST[index].gainAtEachLevel[character.classLevels[index]]) {
                                          if (x[0] == "Choice") {
                                            widgetsInPlay.add(SizedBox(
                                                height: 85,
                                                child: ChoiceRow(
                                                  x: x.sublist(1),
                                                  allSelected: character.allSelected,
                                                )));
                                          } else {
                                            levelGainParser(x, CLASSLIST[index]);
                                          }
                                        }

                                        // Level 1 treated differently for levelling
                                        if (character.classList.length == 1) {
                                          // Bonus feat if that option was selected
                                          if (character.extraFeatAtLevel1 ?? false) {
                                            numberOfRemainingFeatOrASIs++;
                                          }

                                          // Gain hit points (max die roll at lvl 1)
                                          character.maxHealth += CLASSLIST[index].maxHitDiceRoll;
                                          
                                          // Gain saving throw proficiencies
                                          character.savingThrowProficiencies = CLASSLIST[index].savingThrowProficiencies;

                                          // Gain the equipment choices
                                          character.equipmentSelectedFromChoices.addAll(CLASSLIST[index].equipmentOptions);

                                          // Gain the skill proficiencies
                                          character.classSkillsSelected = List.filled(CLASSLIST[index].optionsForSkillProficiencies.length,false);

                                          // Add any further choices needed
                                          widgetsInPlay.addAll([
                                            StyleUtils.buildStyledSmallTextBox(text: "Pick ${(CLASSLIST[index].numberOfSkillChoices)} skill(s) to gain proficiency in"),
                                            const SizedBox(height: 7),
                                            StatefulBuilder(
                                              builder: (context, setState) { return StyleUtils.buildStyledToggleSelector(
                                              itemLabels: CLASSLIST[index].optionsForSkillProficiencies,
                                              isSelected: character.classSkillsSelected,
                                              onPressed: (int subIndex, bool _) {
                                                setState(() {
                                                // Gain background skill choices
                                                if (character.classSkillsSelected.where((b) => b).length <
                                                    CLASSLIST[index].numberOfSkillChoices) {
                                                  character.classSkillsSelected[subIndex] = !character.classSkillsSelected[subIndex];
                                                } else {
                                                  if (character.classSkillsSelected[subIndex]) {
                                                    character.classSkillsSelected[subIndex] = false;
                                                  }
                                                }
                                                tabRebuildNotifier.value++;
                                              });}
                                            );})
                                          ]);
                                        }
                                        // Health calculated in a normal way if not level 1
                                        else {
                                          if (character.averageHitPoints ?? false) {
                                            character.maxHealth += ((CLASSLIST[index].maxHitDiceRoll) / 2).ceil();
                                          } else {
                                            character.maxHealth += 1 + (Random().nextDouble() * CLASSLIST[index].maxHitDiceRoll).floor();
                                          }
                                        }

                                        // Check if it's a spellcaster, if so add the necessary spell info
                                        if (CLASSLIST[index].classType != "Martial") {
                                          if (character.classList.where((element) => element == CLASSLIST[index].name).length == 1) {
                                            character.allSpellsSelectedAsListsOfThings.add([
                                              CLASSLIST[index].name,
                                              [],
                                              levelZeroGetSpellsKnown(index),
                                              CLASSLIST[index].spellsKnownFormula ?? CLASSLIST[index].spellsKnownPerLevel
                                            ]); 
                                          } else {
                                            var a = character.classSubclassMapper[CLASSLIST[index].name];
                                            for (var x = 0; x < character.allSpellsSelectedAsListsOfThings.length; x++) {
                                              if (character.allSpellsSelectedAsListsOfThings[x][0] == CLASSLIST[index].name) {
                                                character.allSpellsSelectedAsListsOfThings[x][2] =
                                                    getSpellsKnown(
                                                        index,
                                                        character.allSpellsSelectedAsListsOfThings[x]);
                                              } else if (a != null) {
                                                if (character.allSpellsSelectedAsListsOfThings[x][0] == a) {
                                                  character.allSpellsSelectedAsListsOfThings[x][2] =
                                                    getSpellsKnown(
                                                      index,
                                                      character.allSpellsSelectedAsListsOfThings[x]
                                                    );
                                                }
                                              }
                                            }
                                          }
                                        }

                                        // Increment the class level
                                        character.classLevels[index]++;
                                      }
                                    });
                                  },
                                  child: Icon(Icons.add, color: InitialTop.colourScheme.textColour, size: 35))
                              ],
                            ));
                        }),
                      ),
                    )),
                Column(children: widgetsInPlay)
              ]),
            ),
          ),
          
          // Background Tab
          BackgroundTab(
            character: character,
            onCharacterChanged: () {
              setState(() {});
            },
          ),
          
          // Ability Score Tab
          AbilityScoreTab(
            character: character,
            pointsRemaining: pointsRemaining,
            onPointsRemainingChanged: (newPoints) {
              setState(() {
                pointsRemaining = newPoints;
              });
            },
          ),
                    
          // Ability Score Improvement & Feat selection tab
          AsiFeatTab(
            character: character,
            numberOfRemainingFeatOrASIs: numberOfRemainingFeatOrASIs,
            remainingAsi: remainingAsi,
            widgetsInPlay: widgetsInPlay,
            onCharacterChanged: () {
              setState(() {});
            },
            onRemainingFeatOrASIsChanged: (newCount) {
              setState(() {
                numberOfRemainingFeatOrASIs = newCount;
              });
            },
            onRemainingAsiChanged: (newValue) {
              setState(() {
                remainingAsi = newValue;
              });
            },
            onWidgetsInPlayChanged: (newWidgets) {
              setState(() {
                widgetsInPlay = newWidgets;
              });
            },
          ),

          // Spells Tab
          SpellsTab(
            character: character,
            onCharacterChanged: () {
              setState(() {});
            },
          ),
          
          // Equipment Tab
          EquipmentTab(
            character: character,
            coinTypesSelected: coinTypesSelected,
            onCharacterChanged: () {
              setState(() {});
            },
            onCoinTypesChanged: (newCoinTypes) {
              setState(() {
                coinTypesSelected = newCoinTypes;
              });
            },
          ),
          
          // Backstory Tab
          BackstoryTab(
            character: character,
            onCharacterChanged: () {
              setState(() {
                // This will trigger a rebuild if other tabs need to reflect backstory changes
              });
              // DO NOTHING AS BACKSTORY CHANGES DO NOT AFFECT OTHER TABS
            },
          ),
          
          // Finishing Up Tab
          FinishingUpTab(
            character: character,
            groupEnterController: groupEnterController,
            canCreateCharacter: canCreateCharacter,
            pointsRemaining: pointsRemaining,
            numberOfRemainingFeatOrASIs: numberOfRemainingFeatOrASIs,
            remainingAsi: remainingAsi,
            charLevel: charLevel,
            onCharacterChanged: () {
              setState(() {});
            },
            onSaveCharacter: () {
              setState(() {});
            },
            showCongratulationsDialog: showCongratulationsDialog,
          ),
        ]),
      ),
    );});
  }

  void showCongratulationsDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        content: const Text('Character created!',
            style: TextStyle(
                color: Colors.green,
                fontSize: 50,
                fontWeight: FontWeight.w800)),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
            },
            child: const Text('Continue'),
          ),
        ],
      ),
    );
  }

  bool scoresFailRequirement(Character character, List<int> requirements) {
    int count = 0;
    if (character.strength.value + character.raceAbilityScoreIncreases[0] + character.featsASIScoreIncreases[0] >= requirements[0]) count++;
    if (character.dexterity.value + character.raceAbilityScoreIncreases[1] + character.featsASIScoreIncreases[1] >= requirements[1]) count++;
    if (character.constitution.value + character.raceAbilityScoreIncreases[2] + character.featsASIScoreIncreases[2] >= requirements[2]) count++;
    if (character.intelligence.value + character.raceAbilityScoreIncreases[3] + character.featsASIScoreIncreases[3] >= requirements[3]) count++;
    if (character.wisdom.value + character.raceAbilityScoreIncreases[4] + character.featsASIScoreIncreases[4] >= requirements[4]) count++;
    if (character.charisma.value + character.raceAbilityScoreIncreases[5] + character.featsASIScoreIncreases[5] >= requirements[5]) count++;

    return count >= requirements[6];
  }
  
  bool multiclassingPossible(Class selectedClass) {
    // Check if it is their first class or they already have a level in the class
    if (character.classList.isEmpty || character.classList.contains(selectedClass.name)) {
      return true;
    }

    // Check if multiclassing is allowed
    if (!(character.multiclassing ?? false)) {
      return false;
    }

    // Check they satisfy the class they want to take
    if (scoresFailRequirement(character, selectedClass.multiclassingRequirements)) {
      return false;
    }

    // Check they satisfy their last added class's requirements
    return scoresFailRequirement(character, CLASSLIST.last.multiclassingRequirements);
  }

  Widget? levelGainParser(List<dynamic> x, Class selectedClass) {
    //Levelup(class?)
    if (x[0] == "Level") {
      // ("Level", "numb")
      return Text(
        "${selectedClass.name} Level ${x[1]} choice(s):",
        style: const TextStyle(
            fontSize: 25,
            fontWeight: FontWeight.w700,
            color: Color.fromARGB(255, 0, 168, 252)),
      );
    } else if (x[0] == "Nothing") {
      // ("Nothing", "numb")
      return Text(
        "No choices needed for ${selectedClass.name} level ${x[1]}",
        style: const TextStyle(
            fontSize: 25,
            fontWeight: FontWeight.w700,
            color: Color.fromARGB(255, 0, 168, 252)),
      );
    } else if (x[0] == "Bonus") {
      // ("Bonus","String description")
      character.featuresAndTraits.add("${x[1]}: ${x[2]}");
    } else if (x[0] == "AC") {
      // ("AC","intelligence + 2", "RQUIREMENT")
      character.ACList.add([x[1], x[2]]);
    } else if (x[0] == "Speed") {
      //note base speed is given by race
      //("speed", (w/s/c/f/h), numb/expression")
      character.speedBonuses[x[1]]?.add(x[2]);
    } else if (x[0] == "AttributeBoost") {
      if (x[1] == "Intelligence") {
        character.intelligence.value += int.parse(x[2]);
      } else if (x[1] == "Strength") {
        character.strength.value += int.parse(x[2]);
      } else if (x[1] == "Constitution") {
        character.constitution.value += int.parse(x[2]);
      } else if (x[1] == "Dexterity") {
        character.dexterity.value += int.parse(x[2]);
      } else if (x[1] == "Wisdom") {
        character.wisdom.value += int.parse(x[2]);
      } else if (x[1] == "charisma") {
        character.charisma.value += int.parse(x[2]);
      }
      //do this later
    } else if (x[0] == "Gained") {
      character.skillBonusMap[x[1]] = character.skillBonusMap[x[1]]! + int.parse(x[2]);
      //do this later
    } else if (x[0] == "ASI") {
      numberOfRemainingFeatOrASIs++;
    }
    //FUTUREPLAN(Implement further parsing for: proficiencies, languages, equipment )

    /*else if (x[0] == "Equipment") {
    //note base speed is given by race
    //("speed", "10", "(w/s/c/f)")
    SPEEDLIST.append([x[1], x[2]]);
  }*/
    else if (x[0] == "Money") {
      //("Money", "Copper Pieces", "10")
      character.currency[x[1]] = character.currency[x[1]]! + int.parse(x[2]);
    }
    return null;
  }

  int levelZeroGetSpellsKnown(int index) {
    if (CLASSLIST[index].spellsKnownFormula == null) {
      return CLASSLIST[index].spellsKnownPerLevel![character.classLevels[index]];
    }
    //decode as zero
    return 3;
  }

  int getSpellsKnown(int index, List<dynamic> thisStuff) {
    if (CLASSLIST[index].spellsKnownFormula == null) {
      return (CLASSLIST[index].spellsKnownPerLevel![character.classLevels[index]] -
          thisStuff[1].length) as int;
    }
    //decode as level + 1 and then take away [1].length
    return 3;
  }
}
