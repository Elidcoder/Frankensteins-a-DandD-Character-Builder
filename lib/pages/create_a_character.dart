// External Imports
import "package:flutter/material.dart";
import "dart:math";

// Project Imports
import "spell_handling.dart";
import "../main.dart";
import "../content_classes/all_content_classes.dart";
import "../file_manager.dart";
import "../pdf_generator/pdf_final_display.dart";

/* Notifier for when settings changes colour to rebuild. */
final ValueNotifier<int> tabRebuildNotifier = ValueNotifier<int>(0);

class CreateACharacter extends StatefulWidget {
  const CreateACharacter({super.key});

  @override
  MainCreateCharacter createState() => MainCreateCharacter();
}

class MainCreateCharacter extends State<CreateACharacter>
    with AutomaticKeepAliveClientMixin {
  @override
  bool get wantKeepAlive => true;

  // Text editing controllers
  /// Basics 
  TextEditingController nameEnterController = TextEditingController();
  TextEditingController playerNameEnterController = TextEditingController();
  TextEditingController genderEnterController = TextEditingController();
  /// Backstory
  //// Short answers 
  TextEditingController ageEnterController = TextEditingController();
  TextEditingController heightEnterController = TextEditingController();
  TextEditingController weightEnterController = TextEditingController();
  TextEditingController eyeColourController = TextEditingController();
  TextEditingController skinEnterController = TextEditingController();
  TextEditingController hairEnterController = TextEditingController();
  //// Long answers
  TextEditingController backstoryEnterController = TextEditingController();
  TextEditingController additionalFeaturesEnterController =
      TextEditingController();
  /// Character group
  TextEditingController groupEnterController = TextEditingController();
  
  static const List<String> tabLabels = [
    "Basics",
    "Race",
    "Class",
    "Background",
    "Ability Scores",
    "ASIs and Feats",
    "Spells",
    "Equipment",
    "Backstory",
    "Finishing up"
  ];

  static const List<String> abilityScores = [
    "Strength",
    "Dexterity",
    "Constitution",
    "Intelligence",
    "Wisdom",
    "Charisma"
  ];

  /* Define colours that will be used a lot. */
  static const Color unavailableColor = Color.fromARGB(247, 56, 53, 52);
  static const Color positiveColor    = Color.fromARGB(255, 10, 126, 54);
  static const Color negativeColor    = Color.fromARGB(255, 172, 46, 46);
  static const Color notIdealColor    = Colors.orange;
  
  // Stores the widgets generated by class levels
  List<Widget> widgetsInPlay = []; 
  String? levellingMethod;
  String? characterLevel = "1";
  int pointsRemaining = 27;
  List<String> coinTypesSelected = ["Gold"];
  Map<String, bool> featFilters = {
    "Half Feats": true,
    "Full Feats": true
  };
  List<Feat> get filteredFeats {
    List<Feat> feats = FEATLIST.where((feat) => (feat.isHalfFeat && featFilters["Half Feats"]!) || (!feat.isHalfFeat && featFilters["Full Feats"]!)).toList();
    return feats;
  }

  int numberOfRemainingFeatOrASIs = 0;
  bool remainingAsi = false;
  

  // FUTUREPLAN(Implement an experience levelling alternative using these)
  String enteredExperience = "";
  TextEditingController experienceEnterController = TextEditingController();
  
  // FUTUREPLAN(Implement a better skill proficiency section using skillProficienciesMap and adding a second field then delete this)
  List<String> skillProficiencies = [];

  Character character = Character.createDefault();

  List<bool> get backgroundSelectedSkills {
    List<String> options = character.background.optionalSkillProficiencies;
    return options.map((x) => character.skillsSelected.contains(x)).toList();
  }

  List<bool> get backgroundSelectedLanguages {
    List<String> options = character.background.getLanguageOptions();
    return options.map((x) => character.languageChoices.contains(x)).toList();
  }

  int get charLevel {
    return int.parse(characterLevel ?? "1");
  }

  bool get canCreateCharacter {
    return (pointsRemaining == 0 &&
      numberOfRemainingFeatOrASIs == 0 &&
      !remainingAsi &&
      charLevel <= character.classList.length &&
      character.chosenAllEqipment && 
      character.chosenAllSpells
    );
  }

  @override
  Widget build(
    BuildContext context,
  ) {
    super.build(context);

    /* Calculate the items meeting user filters. */
    List<Item> filteredItems = ITEMLIST.where((element) =>
      ((element.equipmentType.contains("Armour") && element.equipmentType.any((item) => character.armourList.contains(item))) 
      || (element.equipmentType.contains("Weapon") && element.equipmentType.any((item) => character.weaponList.contains(item))) 
      || (element.equipmentType.contains("Item") && ((character.itemList.contains("Stackable") && element.stackable) 
      || (character.itemList.contains("Unstackable") && !element.stackable)))) && coinTypesSelected.contains(element.cost[1] as String)
      ).toList();

    return ValueListenableBuilder<int>(
      valueListenable: tabRebuildNotifier,
      builder: (context, value, child) {return DefaultTabController(
      length: tabLabels.length,
      child: Scaffold(
        backgroundColor: InitialTop.colourScheme.backgroundColour,
        appBar: AppBar(
          foregroundColor: InitialTop.colourScheme.textColour,
          backgroundColor: InitialTop.colourScheme.backingColour,
          title: const Center(
            child: Text(
              textAlign: TextAlign.center,
              "Create a character",
              style: TextStyle(fontSize: 40, fontWeight: FontWeight.w700),
            ),
          ),
          bottom: TabBar(
            tabs: tabLabels.map((e) => tabLabel(e)).toList(),
            indicatorColor: InitialTop.colourScheme.textColour,
          ),
        ),
        body: TabBarView(children: [
          // Basics Tab
          SingleChildScrollView(
            scrollDirection: Axis.vertical,
            child: Column(
              children: [
                const SizedBox(height: 65),
                Row(
                  children: [
                    Expanded(
                        child: Column(children: [
                      //title
                      buildSectionHeader("Character info"),
                      const SizedBox(height: 25),
                      //Character name input
                      buildStyledSmallTextField(
                        hintText: "Enter character's name", 
                        textController: nameEnterController, 
                        onChanged: (characterNameEnteredValue) {
                          setState(() {
                            character.characterDescription.name = characterNameEnteredValue;
                          });}
                      ),
                      const SizedBox(height: 15),
                      //Player name input
                      buildStyledSmallTextField(
                        hintText: "Enter the player's name", 
                        textController: playerNameEnterController, 
                        onChanged: (playerNameEnteredValue) {
                          setState(() {
                            character.playerName = playerNameEnteredValue;
                          });}
                      ),
                      const SizedBox(height: 15),
                      //Character gender input
                      buildStyledSmallTextField(
                        hintText: "Enter the character's gender", 
                        textController: genderEnterController, 
                        onChanged:  (characterGenderEnteredValue) {
                          setState(() {
                            character.characterDescription.gender = characterGenderEnteredValue;
                          });}
                      ),
                      const SizedBox(height: 15),
                      //exp/levels section
                      SizedBox(
                        width: 300,
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.center,
                          children: [
                            //use experience
                            buildStyledRadioListTile(
                              title: "Use experience",
                              value: "Experience",
                              groupValue: levellingMethod,
                              onChanged: (value) {
                                setState(() {
                                  levellingMethod = value.toString();
                                });
                              },
                            ),
                            const SizedBox(height: 15),
                            //Experience enterence option if experience is selected
                            //otherwise display the use levels radio tile
                            Container(
                              child: (levellingMethod == "Experience") ? 
                                buildStyledSmallTextField(
                                  hintText: "Enter the character's exp", 
                                  textController: experienceEnterController, 
                                  onChanged:  (characterExperienceEnteredValue) {
                                    setState(() {
                                      //FUTUREPLAN(Implement the experience levelling alternative);
                                    });}
                                ) : 
                                buildStyledRadioListTile(
                                  title: "Use levels",
                                  value: "Levels",
                                  groupValue: levellingMethod,
                                  onChanged: (value) {
                                    setState(() {
                                      levellingMethod = value.toString();
                                    });
                                  },
                                )
                            ),
                            const SizedBox(height: 5),
                            //levels radio tile if experience is selected
                            //otherwise the levels selection option
                            Container(
                              child: (levellingMethod == "Experience") ? 
                                buildStyledRadioListTile(
                                  title: "Use levels",
                                  value: "Levels",
                                  groupValue: levellingMethod,
                                  onChanged: (value) {
                                    setState(() {
                                      levellingMethod = value.toString();
                                    });
                                  },
                                ) : 
                                Container(
                                  decoration: BoxDecoration(
                                    borderRadius: const BorderRadius.all(Radius.circular(5)),
                                    color: InitialTop.colourScheme.backingColour,
                                  ),
                                  height: 45,
                                  child: DropdownButton<String>(
                                    alignment: Alignment.center,
                                    value: characterLevel,
                                    icon: Icon(Icons.arrow_drop_down, color: InitialTop.colourScheme.textColour),
                                    elevation: 16,
                                    style: TextStyle(
                                      color: InitialTop.colourScheme.textColour,
                                      fontWeight: FontWeight.w800,
                                      fontSize: 20),
                                    underline: const SizedBox(),
                                    onChanged: (String? value) {
                                      setState(() {
                                        characterLevel = value!;
                                      });
                                    },
                                    items: [for (var i = charLevel; i <= 20; i += 1) i.toString()]
                                      .toList()
                                      .map<DropdownMenuItem<String>>(
                                          (String value) {
                                        return DropdownMenuItem<String>(
                                          value: value,
                                          child: Align(
                                            child: Text(value,
                                              textAlign: TextAlign.center,
                                              style: TextStyle(
                                                color: InitialTop.colourScheme.textColour,
                                                decoration: TextDecoration.underline,
                                              ))),
                                        );
                                      }).toList(),
                                    dropdownColor:InitialTop.colourScheme.backingColour
                                  ),
                                ),
                            ),
                            const SizedBox(height: 10),
                          ]))
                    ])),
                    Expanded(
                        child: Column(
                      children: [
                        buildSectionHeader("Build Parameters"),
                        const SizedBox(height: 25),
                        SizedBox(
                          width: 325,
                          child: Column(
                            children: [
                              buildStyledCheckboxListTile(
                                title: "Feats in use", 
                                value: character.featsAllowed, 
                                onChanged: (bool? value) {
                                  setState(() {
                                    character.featsAllowed = value;
                                  });}
                              ),
                              const SizedBox(height: 15),
                              buildStyledCheckboxListTile(
                                title: "Use average for hit dice", 
                                value: character.averageHitPoints, 
                                onChanged: (bool? value) {
                                  setState(() {
                                    character.averageHitPoints = value;
                                  });}
                              ),
                              const SizedBox(height: 15),
                              buildStyledCheckboxListTile(
                                title: "Allow multiclassing", 
                                value: character.multiclassing, 
                                onChanged: (bool? value) {
                                  setState(() {
                                    character.multiclassing = value;
                                  });}
                              ),
                              const SizedBox(height: 15),
                              buildStyledCheckboxListTile(
                                title: "Use milestone levelling", 
                                value: character.milestoneLevelling, 
                                onChanged: (bool? value) {
                                  setState(() {
                                    character.milestoneLevelling = value;
                                  });}
                              ),
                              const SizedBox(height: 15),
                              buildStyledCheckboxListTile(
                                title: "Use created content", 
                                value: character.useCustomContent, 
                                onChanged: (bool? value) {
                                  setState(() {
                                    character.useCustomContent = value;
                                  });}
                              ),
                              const SizedBox(height: 15),
                              buildStyledCheckboxListTile(
                                title: "Use optional class features", 
                                value: character.optionalClassFeatures, 
                                onChanged: (bool? value) {
                                  setState(() {
                                    character.optionalClassFeatures = value;
                                  });}
                              ),
                              const SizedBox(height: 8),
                            ],
                          ),
                        ),
                      ],
                    )),
                    Expanded(
                        child: Column(
                        children: [
                        buildSectionHeader("Rarer Parameters"),
                        const SizedBox(height: 25),
                        SizedBox(
                          width: 325,
                          child: Column(
                            children: [
                              buildStyledCheckboxListTile(
                                title: "Use critical role content", 
                                value: character.criticalRoleContent, 
                                onChanged: (bool? value) {
                                  setState(() {
                                    character.criticalRoleContent = value;
                                  });}
                              ),
                              const SizedBox(height: 15),
                              buildStyledCheckboxListTile(
                                title: "Use encumberance rules", 
                                value: character.encumberanceRules, 
                                onChanged: (bool? value) {
                                  setState(() {
                                    character.encumberanceRules = value;
                                  });}
                              ),
                              const SizedBox(height: 15),
                              buildStyledCheckboxListTile(
                                title: "Incude coins' weights", 
                                value: character.includeCoinsForWeight, 
                                onChanged: (bool? value) {
                                  setState(() {
                                    character.includeCoinsForWeight = value;
                                  });}
                              ),
                              const SizedBox(height: 15),
                              buildStyledCheckboxListTile(
                                title: "Use UA content", 
                                value:  character.unearthedArcanaContent, 
                                onChanged: (bool? value) {
                                  setState(() {
                                     character.unearthedArcanaContent = value;
                                  });}
                              ),
                              const SizedBox(height: 15),
                              buildStyledCheckboxListTile(
                                title: "Allow firearms", 
                                value:  character.firearmsUsable, 
                                onChanged: (bool? value) {
                                  setState(() {
                                     character.firearmsUsable = value;
                                  });}
                              ),
                              const SizedBox(height: 15),
                              buildStyledCheckboxListTile(
                                title: "Give an extra feat at lvl 1", 
                                value:  character.extraFeatAtLevel1, 
                                onChanged: (bool? value) {
                                  setState(() {
                                    if (character.classList.isNotEmpty) {
                                      if (character.extraFeatAtLevel1 ?? false) {
                                        if (numberOfRemainingFeatOrASIs > 0) {
                                          numberOfRemainingFeatOrASIs--;
                                          character.extraFeatAtLevel1 = false;
                                        }
                                      } else {
                                        character.extraFeatAtLevel1 = true;
                                        numberOfRemainingFeatOrASIs++;
                                      }
                                    } else {
                                      character.extraFeatAtLevel1 =
                                          !(character.extraFeatAtLevel1 ?? false);
                                    }
                                  });}
                              ),
                              const SizedBox(height: 8),
                            ],
                          ),
                        ),
                      ],
                    ))
                  ],
                )
              ],
            ),
          ),
          
          // Race Tab
          Column(
            children: [
              const SizedBox(height: 24),
              buildStyledMediumTextBox(text: "Select a race:"),
              buildStyledDropDown(
                initialValue: character.race.name, 
                items: RACELIST, 
                onChanged: (String? value) {
                  setState(() {
                    character.raceAbilityScoreIncreases = [0, 0, 0, 0, 0, 0];
                    character.race = RACELIST.singleWhere((x) => x.name == value);
                    character.subrace = character.race.subRaces?.first;
                    
                    for (int i = 0; i < abilityScores.length; i++) {
                      character.raceAbilityScoreIncreases[i] += 
                        character.race.raceScoreIncrease[i] + ((character.subrace?.subRaceScoreIncrease[i]) ?? 0);

                      character.optionalOnesStates = [
                        [false, false, false, false, false, false],
                        [false, false, false, false, false, false],
                        [false, false, false, false, false, false],
                        [false, false, false, false, false, false],
                        [false, false, false, false, false, false]
                      ];
                      character.optionalTwosStates = [
                        [false, false, false, false, false, false],
                        [false, false, false, false, false, false],
                        [false, false, false, false, false, false],
                        [false, false, false, false, false, false],
                        [false, false, false, false, false, false]
                      ];
                  }});
                }
              ),
              const SizedBox(height: 10),
              if (character.race.subRaces != null) ...[
                buildStyledSmallTextBox(text: "Select a subrace:"),
                const SizedBox(height: 10),
                buildStyledDropDown(
                  initialValue: character.subrace?.name,
                  items: character.race.subRaces,
                  onChanged: (String? value) {
                    setState(() {
                      character.raceAbilityScoreIncreases = [0, 0, 0, 0, 0, 0];

                      character.subrace = character.race.subRaces?.singleWhere((x) => x.name == value);
                      for (int i = 0; i < abilityScores.length; i++) {
                        character.raceAbilityScoreIncreases[i] +=
                          (character.subrace?.subRaceScoreIncrease[i] ?? 0) + character.race.raceScoreIncrease[i];
                      }
                      character.optionalOnesStates = [
                        [false, false, false, false, false, false],
                        [false, false, false, false, false, false],
                        [false, false, false, false, false, false],
                        [false, false, false, false, false, false],
                        [false, false, false, false, false, false]
                      ];
                      character.optionalTwosStates = [
                        [false, false, false, false, false, false],
                        [false, false, false, false, false, false],
                        [false, false, false, false, false, false],
                        [false, false, false, false, false, false],
                        [false, false, false, false, false, false]
                      ];
                    });
                  },
                ),
                const SizedBox(height: 10),
              ],
              if (character.race.mystery1S + (character.subrace?.mystery1S ?? 0) != 0) ...[
                buildStyledSmallTextBox(text: "Choose which score(s) to increase by 1"),
                buildNStyledAsiSelectors(
                  numbItems: (character.race.mystery1S + (character.subrace?.mystery1S ?? 0)), 
                  optionalStates: character.optionalOnesStates!, 
                  onPressed:(int choiceNumber, int index, bool isSelected) {
                    setState(() {
                      if (character.optionalOnesStates![choiceNumber][index]) {
                        character.raceAbilityScoreIncreases[index] -= 1;
                      } else {
                        character.raceAbilityScoreIncreases[index] += 1;
                        for (int buttonIndex = choiceNumber;
                            buttonIndex < character.optionalOnesStates![choiceNumber].length;
                            buttonIndex++) {
                          if (character.optionalOnesStates![choiceNumber][buttonIndex]) {
                            character.optionalOnesStates![choiceNumber][buttonIndex] = false;
                            character.raceAbilityScoreIncreases[buttonIndex] -= 1;
                          }
                        }
                      }
                      character.optionalOnesStates![choiceNumber][index] = !character.optionalOnesStates![choiceNumber][index];
                    });
                  }
                ),
              ],
              if (character.race.mystery2S + (character.subrace?.mystery2S ?? 0) != 0) ...[
                buildStyledSmallTextBox(text: "Choose which score(s) to increase by 2"),
                buildNStyledAsiSelectors(
                  numbItems: (character.race.mystery2S + (character.subrace?.mystery2S ?? 0)), 
                  optionalStates: character.optionalTwosStates!,
                  onPressed:(int choiceNumber, int index, bool isSelected) {
                    setState(() {
                      if (character.optionalTwosStates![choiceNumber][index]) {
                        character.raceAbilityScoreIncreases[index] -= 1;
                      } else {
                        character.raceAbilityScoreIncreases[index] += 1;
                        for (
                          int buttonIndex = choiceNumber;
                          buttonIndex < character.optionalTwosStates![choiceNumber].length;
                          buttonIndex++
                          ) {
                            if (character.optionalTwosStates![choiceNumber][buttonIndex]) {
                              character.optionalTwosStates![choiceNumber][buttonIndex] = false;
                              character.raceAbilityScoreIncreases[buttonIndex] -= 1;
                            }
                        }
                      }
                      character.optionalTwosStates![choiceNumber][index] = !character.optionalTwosStates![choiceNumber][index];
                    });
                  }
                )
              ]                
            ],
          ),

          // Class Tab
          DefaultTabController(
            length: 2,
            child: Scaffold(
              backgroundColor: InitialTop.colourScheme.backgroundColour,
              floatingActionButton: FloatingActionButton(
                tooltip: "Increase character level by 1",
                foregroundColor: InitialTop.colourScheme.textColour,
                backgroundColor: (charLevel < 20)
                  ? InitialTop.colourScheme.backingColour
                  : unavailableColor,
                onPressed: () {
                  if (charLevel < 20) {
                    setState(() {
                      characterLevel = "${charLevel + 1}";
                    });
                  }
                },
                child: const Icon(Icons.exposure_plus_1),
              ),
              appBar: AppBar(
                foregroundColor: InitialTop.colourScheme.textColour,
                backgroundColor: InitialTop.colourScheme.backingColour,

                /* Remove default back button */
                leading: IconButton(
                  icon: Icon(Icons.arrow_back, color: InitialTop.colourScheme.backingColour),
                  onPressed: () {},
                ),

                
                /* Class choices available and taken to/by the user. */
                title: Column(
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    Center(
                      child: buildStyledMediumTextBox(
                        text: "${charLevel - character.classLevels.reduce(sum)} class level(s) unselected",
                        color: InitialTop.colourScheme.textColour)
                      ),
                    character.classList.isNotEmpty
                      ? buildStyledSmallTextBox(
                        text: "Levels in Classes: ${CLASSLIST.asMap().entries.where((entry) => character.classLevels[entry.key] != 0).map((entry) => "${entry.value.name} - ${character.classLevels[entry.key]}").join(", ")}",
                        color: InitialTop.colourScheme.textColour)                        
                      :  buildStyledSmallTextBox(
                        text: "No levels selected in any class",
                        color: InitialTop.colourScheme.textColour),
                    const SizedBox(height: 3)
                  ],
                ),
                bottom: TabBar(
                  tabs: [
                    tabLabel("Choose your classes"),
                    tabLabel("Make your selections for each level in your class")
                  ],
                  indicatorColor: InitialTop.colourScheme.textColour,
                ),
              ),
              body: TabBarView(children: [
                /* Generates a set of cards (1 for each class) with buttons allowing 
                 * users to view and select each class */
                Container(
                    padding: const EdgeInsets.only(top: 17),
                    child: SingleChildScrollView(
                      scrollDirection: Axis.vertical,
                      child: Wrap(
                        spacing: 8.0,
                        runSpacing: 8.0,
                        alignment: WrapAlignment.center,
                        children: List.generate(CLASSLIST.length, (index) {
                          return Container(
                            width: 240,
                            height: 175,
                            decoration: BoxDecoration(
                              color: InitialTop.colourScheme.backingColour,
                              border: Border.all(color: Colors.black, width: 1.8),
                              borderRadius: const BorderRadius.all(Radius.circular(5)),
                            ),
                            child: Column(
                              children: [
                                /* Information about the class */
                                Text(CLASSLIST[index].name,
                                  style: TextStyle(
                                    fontSize: 30,
                                    fontWeight: FontWeight.w700,
                                    color: InitialTop.colourScheme.textColour)),
                                buildStyledTinyTextBox(
                                  text: "Class type: ${CLASSLIST[index].classType}", 
                                  color: InitialTop.colourScheme.textColour
                                ),
                                buildStyledTinyTextBox(
                                  text: (["Martial", "Third Caster"].contains(CLASSLIST[index].classType))
                                    ? "Main ability: ${CLASSLIST[index].mainOrSpellcastingAbility}"
                                    : "Spellcasting ability: ${CLASSLIST[index].mainOrSpellcastingAbility}", 
                                  color: InitialTop.colourScheme.textColour
                                ),
                                buildStyledTinyTextBox(
                                  text: "Hit die: D${CLASSLIST[index].maxHitDiceRoll}", 
                                  color: InitialTop.colourScheme.textColour
                                ),
                                buildStyledTinyTextBox(
                                  text: "Saves: ${CLASSLIST[index].savingThrowProficiencies.join(", ")}", 
                                  color: InitialTop.colourScheme.textColour
                                ),
                                const SizedBox(height: 7),

                                /* Button to take a level in the class */
                                ElevatedButton(
                                  style: OutlinedButton.styleFrom(
                                    backgroundColor: (charLevel <= character.classLevels.reduce(sum) || (!multiclassingPossible(CLASSLIST[index])))
                                      ? unavailableColor
                                      : InitialTop.colourScheme.backingColour,
                                    shape: const RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(4))),
                                    side: const BorderSide(width: 3, color: positiveColor)
                                  ),
                                  onPressed: () {
                                    setState(() {

                                      // Check if the character can level up in the class
                                      if (charLevel > character.classList.length && (multiclassingPossible(CLASSLIST[index]))) {
                                        character.classList.add(CLASSLIST[index].name);

                                        if (CLASSLIST[index].gainAtEachLevel[character.classLevels[index]]
                                                .where((element) => element[0] == "Choice").isEmpty) {
                                          widgetsInPlay.add(buildStyledSmallTextBox(text: "No choices needed for ${CLASSLIST[index].name} level ${CLASSLIST[index].gainAtEachLevel[character.classLevels[index]][0][1]}"));
                                        } else {
                                          widgetsInPlay.add(buildStyledMediumTextBox(text: "${CLASSLIST[index].name} Level ${CLASSLIST[index].gainAtEachLevel[character.classLevels[index]][0][1]} choice(s):"));
                                        }

                                        for (List<dynamic> x in CLASSLIST[index].gainAtEachLevel[character.classLevels[index]]) {
                                          if (x[0] == "Choice") {
                                            widgetsInPlay.add(SizedBox(
                                                height: 85,
                                                child: ChoiceRow(
                                                  x: x.sublist(1),
                                                  allSelected: character.allSelected,
                                                )));
                                          } else {
                                            levelGainParser(x, CLASSLIST[index]);
                                          }
                                        }

                                        // Level 1 treated differently for levelling
                                        if (character.classList.length == 1) {
                                          // Bonus feat if that option was selected
                                          if (character.extraFeatAtLevel1 ?? false) {
                                            numberOfRemainingFeatOrASIs++;
                                          }

                                          // Gain hit points (max die roll at lvl 1)
                                          character.maxHealth += CLASSLIST[index].maxHitDiceRoll;
                                          
                                          // Gain saving throw proficiencies
                                          character.savingThrowProficiencies = CLASSLIST[index].savingThrowProficiencies;

                                          // Gain the equipment choices
                                          character.equipmentSelectedFromChoices.addAll(CLASSLIST[index].equipmentOptions);

                                          // Gain the skill proficiencies
                                          character.classSkillsSelected = List.filled(CLASSLIST[index].optionsForSkillProficiencies.length,false);

                                          // Add any further choices needed
                                          widgetsInPlay.addAll([
                                            buildStyledSmallTextBox(text: "Pick ${(CLASSLIST[index].numberOfSkillChoices)} skill(s) to gain proficiency in"),
                                            const SizedBox(height: 7),
                                            StatefulBuilder(
                                              builder: (context, setState) { return buildStyledToggleSelector(
                                              itemLabels: CLASSLIST[index].optionsForSkillProficiencies,
                                              isSelected: character.classSkillsSelected,
                                              onPressed: (int subIndex, bool _) {
                                                setState(() {
                                                // Gain background skill choices
                                                if (character.classSkillsSelected.where((b) => b).length <
                                                    CLASSLIST[index].numberOfSkillChoices) {
                                                  character.classSkillsSelected[subIndex] = !character.classSkillsSelected[subIndex];
                                                } else {
                                                  if (character.classSkillsSelected[subIndex]) {
                                                    character.classSkillsSelected[subIndex] = false;
                                                  }
                                                }
                                                tabRebuildNotifier.value++;
                                              });}
                                            );})
                                          ]);
                                        }
                                        // Health calculated in a normal way if not level 1
                                        else {
                                          if (character.averageHitPoints ?? false) {
                                            character.maxHealth += ((CLASSLIST[index].maxHitDiceRoll) / 2).ceil();
                                          } else {
                                            character.maxHealth += 1 + (Random().nextDouble() * CLASSLIST[index].maxHitDiceRoll).floor();
                                          }
                                        }

                                        // Check if it's a spellcaster, if so add the necessary spell info
                                        if (CLASSLIST[index].classType != "Martial") {
                                          if (character.classList.where((element) => element == CLASSLIST[index].name).length == 1) {
                                            character.allSpellsSelectedAsListsOfThings.add([
                                              CLASSLIST[index].name,
                                              [],
                                              levelZeroGetSpellsKnown(index),
                                              CLASSLIST[index].spellsKnownFormula ?? CLASSLIST[index].spellsKnownPerLevel
                                            ]); 
                                          } else {
                                            var a = character.classSubclassMapper[CLASSLIST[index].name];
                                            for (var x = 0; x < character.allSpellsSelectedAsListsOfThings.length; x++) {
                                              if (character.allSpellsSelectedAsListsOfThings[x][0] == CLASSLIST[index].name) {
                                                character.allSpellsSelectedAsListsOfThings[x][2] =
                                                    getSpellsKnown(
                                                        index,
                                                        character.allSpellsSelectedAsListsOfThings[x]);
                                              } else if (a != null) {
                                                if (character.allSpellsSelectedAsListsOfThings[x][0] == a) {
                                                  character.allSpellsSelectedAsListsOfThings[x][2] =
                                                    getSpellsKnown(
                                                      index,
                                                      character.allSpellsSelectedAsListsOfThings[x]
                                                    );
                                                }
                                              }
                                            }
                                          }
                                        }

                                        // Increment the class level
                                        character.classLevels[index]++;
                                      }
                                    });
                                  },
                                  child: Icon(Icons.add, color: InitialTop.colourScheme.textColour, size: 35))
                              ],
                            ));
                        }),
                      ),
                    )),
                Column(children: widgetsInPlay)
              ]),
            ),
          ),
          
          // Background Tab
          SingleChildScrollView(
              scrollDirection: Axis.vertical,
              child: Column(
                children: [
                  const SizedBox(height: 24),
                  buildStyledMediumTextBox(text: "Select your character's background"),
                  const SizedBox(height: 8),
                  buildStyledDropDown(
                    initialValue: character.background.name, 
                    items: BACKGROUNDLIST, 
                    onChanged: (String? value) {                            
                      setState(() {
                        character.background = BACKGROUNDLIST.singleWhere((x) => x.name == value);
                        character.backgroundPersonalityTrait = character.background.personalityTrait.first;
                        character.backgroundIdeal = character.background.ideal.first;
                        character.backgroundBond = character.background.bond.first;
                        character.backgroundFlaw = character.background.flaw.first;
                        character.skillsSelected.clear();
                        backgroundSelectedSkills;
                        character.languageChoices.clear();
                      });
                    }
                  ),
                  
                  //Personality Trait
                  buildLabeledDropdown(
                    labelText: "Select your character's personality trait",
                    items: character.background.personalityTrait, 
                    selectedValue: character.backgroundPersonalityTrait,
                    onChanged: (String? value) {
                      setState(() {
                        character.backgroundPersonalityTrait = character.background
                                .personalityTrait
                                .singleWhere((x) => x == value);
                      });
                    }
                  ),
                  
                  //Ideal
                  buildLabeledDropdown(
                    labelText: "Select your character's ideal",
                    items: character.background.ideal,
                    selectedValue: character.backgroundIdeal,
                    onChanged: (String? value) {
                      setState(() {
                        character.backgroundIdeal = character.background.ideal
                                .singleWhere((x) => x == value);
                      });
                    }
                  ),
                  
                  //Bond
                  buildLabeledDropdown(
                    labelText: "Select your character's bond",
                    items: character.background.bond, 
                    selectedValue: character.backgroundBond,
                    onChanged: (String? value) {
                      setState(() {
                        character.backgroundBond = character.background.bond
                                  .singleWhere((x) => x == value);
                      });
                    }
                  ),
                  
                  //Flaw
                  buildLabeledDropdown(
                    labelText: "Select your character's flaw",
                    items: character.background.flaw, 
                    selectedValue: character.backgroundFlaw,
                    onChanged: (String? value) {
                      setState(() {
                        character.backgroundFlaw = character.background.flaw
                                  .singleWhere((x) => x == value);
                      });
                    }
                  ),
                  
                  // Select background provided skills if the character gets some and there are options for skills
                  if (character.background.numberOfSkillChoices != 0 && character.background.optionalSkillProficiencies.isNotEmpty) ...[
                    buildStyledSmallTextBox(text: "Pick ${(character.background.numberOfSkillChoices)} skill(s) to gain proficiency in"),
                    const SizedBox(height: 7),
                    buildStyledToggleSelector(
                      isSelected: backgroundSelectedSkills,
                      itemLabels: character.background.optionalSkillProficiencies, 
                      onPressed: (int index, bool _) {
                        setState(() {
                          List<String> skillOptions = character.background.optionalSkillProficiencies;
                          assert(skillOptions.length > index, "Index out of bounds");

                          String skill = skillOptions[index];
                          if (character.skillsSelected.contains(skill)) {
                            character.skillsSelected.remove(skill);
                          } else {
                            character.skillsSelected.add(skill);
                            if (character.skillsSelected.length > character.background.numberOfSkillChoices) {
                              character.skillsSelected.removeFirst();
                            }
                          }
                          backgroundSelectedSkills;
                        });
                      }
                    ) 
                  ],

                  // Select background provided languages
                  if (character.background.numberOfLanguageChoices != 0) ...[
                    buildStyledSmallTextBox(text: "Pick ${(character.background.numberOfLanguageChoices)} language(s) to learn"),
                    const SizedBox(height: 7),
                    buildStyledToggleSelector(
                      isSelected: backgroundSelectedLanguages,
                      itemLabels: character.background.getLanguageOptions(), 
                      onPressed: (int index, bool _) {
                        setState(() {
                          List<String> langOptions = character.background.getLanguageOptions();
                          assert(langOptions.length > index, "Index out of bounds");

                          String language = langOptions[index];
                          if (character.languageChoices .contains(language)) {
                            character.languageChoices.remove(language);
                          } else {
                            character.languageChoices.add(language);
                            if (character.languageChoices.length > character.background.numberOfLanguageChoices) {
                              character.languageChoices.removeFirst();
                            }
                          }
                          backgroundSelectedSkills;
                        });
                      }
                    )
                  ]
                ],
              )),
          
          // Ability Score Tab
          SingleChildScrollView(
            scrollDirection: Axis.vertical,
            child: Column(children: [
              const SizedBox(height: 29),
              Text(
                textAlign: TextAlign.center,
                "Points remaining: $pointsRemaining",
                style: TextStyle(fontSize: 50, fontWeight: FontWeight.w700, color: InitialTop.colourScheme.backingColour),
              ),
              const SizedBox(height: 35),
              SingleChildScrollView(
                scrollDirection: Axis.horizontal,
                child: Row(
                  children: [
                    const SizedBox(width: 20),
                    buildAbilityScoreBlock(score: character.strength),
                    const SizedBox(width: 10),
                    buildAbilityScoreBlock(score: character.dexterity),
                    const SizedBox(width: 10),
                    buildAbilityScoreBlock(score: character.constitution),
                    const SizedBox(width: 10),
                    buildAbilityScoreBlock(score: character.intelligence),
                    const SizedBox(width: 10),
                    buildAbilityScoreBlock(score: character.wisdom),
                    const SizedBox(width: 10),
                    buildAbilityScoreBlock(score: character.charisma)
                  ],
              ))
          ])),
                    
          // Ability Score Improvement & Feat selection tab
          SingleChildScrollView(
            scrollDirection: Axis.vertical,
            child: Column(
              children: [
                const SizedBox(height: 24),
                buildStyledHugeTextBox(text: "$numberOfRemainingFeatOrASIs options remaining"),
                const SizedBox(height: 6),
                Row(
                  children: [
                    /* Display ASI options. */
                    Expanded(
                      child: SizedBox(
                        height: 550,
                        child: Column(
                          children: [
                            if (remainingAsi)
                              buildStyledLargeTextBox(text: "You have an unused ASI")
                            else  
                              buildStyledHugeTextBox(text: "ASI's"),
                            const SizedBox(height: 8),
                            buildAsiBlockRow(scoreLeft: character.strength, scoreRight: character.intelligence),
                            const SizedBox(height: 10),
                            buildAsiBlockRow(scoreLeft: character.dexterity, scoreRight: character.wisdom),
                            const SizedBox(height: 10),
                            buildAsiBlockRow(scoreLeft: character.constitution, scoreRight: character.charisma)
                          ],
                        )
                      )
                    ),

                    /* If feats are allowed display feats options. */
                    if (character.featsAllowed ?? false)
                      Expanded(
                        child: SizedBox(
                          height: 550,
                          child: Column(
                            children: [
                              /* Title */
                              buildStyledLargeTextBox(text: "Select Feats:"),
                              const SizedBox(height: 8),

                              /* Filters for the feat selection box */
                              SizedBox(
                                child: Row(
                                  mainAxisAlignment: MainAxisAlignment.center,
                                  children: [
                                    buildBinarySelectorButton(key: "Full Feats"),                 
                                    buildBinarySelectorButton(key: "Half Feats"),
                                ])),
                              const SizedBox(height: 10),

                              /* Feat selection box */
                              Container(
                                height: 140,
                                width: 300,
                                decoration: BoxDecoration(
                                  color: unavailableColor,
                                  border: Border.all(color: Colors.black, width: 3),
                                  borderRadius: const BorderRadius.all(Radius.circular(8)),
                                ),
                                child: ListView.builder(
                                  scrollDirection: Axis.vertical,
                                  shrinkWrap: true,
                                  itemCount: filteredFeats.length,
                                  itemBuilder: (context, index) {
                                    return Tooltip(
                                      message: filteredFeats[index].display(),
                                      child: OutlinedButton(
                                        style: OutlinedButton.styleFrom(
                                          /* Create a colouring gradient for feats that can be selected multiple times */
                                          backgroundColor: (character.featsSelected.where((feat) => feat[0].name == filteredFeats[index].name).isNotEmpty) ? Color.fromARGB(
                                            100 + (((character.featsSelected.where((feat) => feat[0].name == filteredFeats[index].name).length) / filteredFeats[index].numberOfTimesTakeable) * 155).ceil(),
                                            0,
                                            50 + (((character.featsSelected.where((feat) => feat[0].name == filteredFeats[index].name).length) / filteredFeats[index].numberOfTimesTakeable) * 205).ceil(),
                                            0
                                          )
                                          : Colors.white,
                                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8))
                                        ),
                                        onPressed: () {
                                          setState(() {
                                            /* Check there are choices available for the feat. */
                                            if (numberOfRemainingFeatOrASIs > 0) {
                                              /* Check the feat hasn't been chosen its maximum amount of times. */
                                              if (character.featsSelected.where(
                                                (element) => element[0].name == filteredFeats[index].name
                                              ).length < filteredFeats[index].numberOfTimesTakeable) {

                                                /* Select the feat */
                                                numberOfRemainingFeatOrASIs --;
                                                character.featsSelected.add([filteredFeats[index]]);

                                                /* Add any necessary choices to the widgetsInPlay */
                                                for (List<dynamic> x in filteredFeats[index].abilities) {
                                                  if (x.first == "Choice") {
                                                    widgetsInPlay.add(SizedBox(height: 80, child: ChoiceRow(x: x.sublist(1),allSelected:character.allSelected)));
                                                  } else {
                                                    levelGainParser(x, CLASSLIST[index]);
                                                  }
                                                }
                                              }
                                            }
                                          },
                                        );
                                      },
                                    child: buildStyledTinyTextBox(text: filteredFeats[index].name)));
                                  },
                                ),
                              ),

                              /* Display the feats the character already has */
                              if (character.featsSelected.isNotEmpty) ...[
                                buildStyledLargeTextBox(text: "Selected Feat${displayPlural(character.featsSelected)}:"),
                                SizedBox(
                                  height: 50,
                                  child: ListView.builder(
                                    scrollDirection: Axis.horizontal,
                                    shrinkWrap: true,
                                    itemCount: character.featsSelected.length,
                                    itemBuilder: (context, index) {
                                      return Tooltip(
                                        message: FEATLIST[index].display(),
                                        child: OutlinedButton(
                                          style: OutlinedButton.styleFrom(
                                            backgroundColor: InitialTop.colourScheme.backingColour,
                                            padding: EdgeInsets.fromLTRB(10, 0, 10, 0),
                                            tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15)),
                                            side: BorderSide(color: Colors.black, width: 2),
                                          ),
                                          onPressed: () {},
                                          child: buildStyledSmallTextBox(text: character.featsSelected[index][0].name, color: InitialTop.colourScheme.textColour)
                                      ));
                                    },
                                  )),
                              ],
                            ],
                      ))),
                  ],
                )
              ],
            )),

          // spells
          Column(children: [
            /* If the character has nothing to do with spells this displays a message.  */
            if (character.allSpellsSelected.isEmpty && character.allSpellsSelectedAsListsOfThings.isEmpty) ...[
              const SizedBox(height: 25),
              buildStyledHugeTextBox(text: "No spells selected or available"),
            ],
            
            /* Displays all the spells selected by the character and all the options available to allow new spell choices. */
            if (character.allSpellsSelected.isNotEmpty || character.allSpellsSelectedAsListsOfThings.isNotEmpty) ...[
              Text("Choose your spells from regular progression",
                  style: TextStyle(
                      fontSize: 28,
                      fontWeight: FontWeight.w700,
                      color: InitialTop.colourScheme.backingColour)),
              Row(children: [
                Expanded(child: Column(children: [
                  (character.allSpellsSelected.isNotEmpty) 
                  ? buildStyledLargeTextBox(text: "Spells learned:")
                  : buildStyledLargeTextBox(text: "No spells learned"),
                  if (character.allSpellsSelected
                      .where((element) => element.level == 0)
                      .toList()
                      .isNotEmpty)
                    const Text("Cantrips:"),
                  if (character.allSpellsSelected
                      .where((element) => element.level == 0)
                      .toList()
                      .isNotEmpty)
                    SizedBox(
                        height: 50,
                        child: ListView.builder(
                          scrollDirection: Axis.horizontal,
                          shrinkWrap: true,
                          itemCount: character.allSpellsSelected
                              .where((element) => element.level == 0)
                              .toList()
                              .length,
                          itemBuilder: (context, index) {
                            return OutlinedButton(
                              style: OutlinedButton.styleFrom(
                                  backgroundColor: Colors.white),
                              onPressed: () {},
                              child: Text(character.allSpellsSelected
                                  .where((element) => element.level == 0)
                                  .toList()[index]
                                  .name),
                            );
                          },
                        )),
                  if (character.allSpellsSelected
                      .where((element) => element.level == 1)
                      .toList()
                      .isNotEmpty)
                    const Text("Level 1 Spells:"),
                  if (character.allSpellsSelected
                      .where((element) => element.level == 1)
                      .toList()
                      .isNotEmpty)
                    SizedBox(
                        height: 50,
                        child: ListView.builder(
                          scrollDirection: Axis.horizontal,
                          shrinkWrap: true,
                          itemCount: character.allSpellsSelected
                              .where((element) => element.level == 1)
                              .toList()
                              .length,
                          itemBuilder: (context, index) {
                            return OutlinedButton(
                              style: OutlinedButton.styleFrom(
                                  backgroundColor: Colors.white),
                              onPressed: () {},
                              child: Text(character.allSpellsSelected
                                  .where((element) => element.level == 1)
                                  .toList()[index]
                                  .name),
                            );
                          },
                        )),
                  if (character.allSpellsSelected
                      .where((element) => element.level == 2)
                      .toList()
                      .isNotEmpty)
                    const Text("Level 2 Spells:"),
                  if (character.allSpellsSelected
                      .where((element) => element.level == 2)
                      .toList()
                      .isNotEmpty)
                    SizedBox(
                        height: 50,
                        child: ListView.builder(
                          scrollDirection: Axis.horizontal,
                          shrinkWrap: true,
                          itemCount: character.allSpellsSelected
                              .where((element) => element.level == 2)
                              .toList()
                              .length,
                          itemBuilder: (context, index) {
                            return OutlinedButton(
                              style: OutlinedButton.styleFrom(
                                  backgroundColor: Colors.white),
                              onPressed: () {},
                              child: Text(character.allSpellsSelected
                                  .where((element) => element.level == 2)
                                  .toList()[index]
                                  .name),
                            );
                          },
                        )),
                  if (character.allSpellsSelected
                      .where((element) => element.level == 3)
                      .toList()
                      .isNotEmpty)
                    const Text("Level 3 Spells:"),
                  if (character.allSpellsSelected
                      .where((element) => element.level == 3)
                      .toList()
                      .isNotEmpty)
                    SizedBox(
                        height: 50,
                        child: ListView.builder(
                          scrollDirection: Axis.horizontal,
                          shrinkWrap: true,
                          itemCount: character.allSpellsSelected
                              .where((element) => element.level == 3)
                              .toList()
                              .length,
                          itemBuilder: (context, index) {
                            return OutlinedButton(
                              style: OutlinedButton.styleFrom(
                                  backgroundColor: Colors.white),
                              onPressed: () {},
                              child: Text(character.allSpellsSelected
                                  .where((element) => element.level == 3)
                                  .toList()[index]
                                  .name),
                            );
                          },
                        )),
                  if (character.allSpellsSelected
                      .where((element) => element.level == 4)
                      .toList()
                      .isNotEmpty)
                    const Text("Level 4 Spells:"),
                  if (character.allSpellsSelected
                      .where((element) => element.level == 4)
                      .toList()
                      .isNotEmpty)
                    SizedBox(
                        height: 50,
                        child: ListView.builder(
                          scrollDirection: Axis.horizontal,
                          shrinkWrap: true,
                          itemCount: character.allSpellsSelected
                              .where((element) => element.level == 4)
                              .toList()
                              .length,
                          itemBuilder: (context, index) {
                            return OutlinedButton(
                              style: OutlinedButton.styleFrom(
                                  backgroundColor: Colors.white),
                              onPressed: () {},
                              child: Text(character.allSpellsSelected
                                  .where((element) => element.level == 4)
                                  .toList()[index]
                                  .name),
                            );
                          },
                        )),
                  if (character.allSpellsSelected
                      .where((element) => element.level == 5)
                      .toList()
                      .isNotEmpty)
                    const Text("Level 5 Spells:"),
                  if (character.allSpellsSelected
                      .where((element) => element.level == 5)
                      .toList()
                      .isNotEmpty)
                    SizedBox(
                        height: 50,
                        child: ListView.builder(
                          scrollDirection: Axis.horizontal,
                          shrinkWrap: true,
                          itemCount: character.allSpellsSelected
                              .where((element) => element.level == 5)
                              .toList()
                              .length,
                          itemBuilder: (context, index) {
                            return OutlinedButton(
                              style: OutlinedButton.styleFrom(
                                  backgroundColor: Colors.white),
                              onPressed: () {},
                              child: Text(character.allSpellsSelected
                                  .where((element) => element.level == 5)
                                  .toList()[index]
                                  .name),
                            );
                          },
                        )),
                  if (character.allSpellsSelected
                      .where((element) => element.level == 6)
                      .toList()
                      .isNotEmpty)
                    const Text("Level 6 Spells:"),
                  if (character.allSpellsSelected
                      .where((element) => element.level == 6)
                      .toList()
                      .isNotEmpty)
                    SizedBox(
                        height: 50,
                        child: ListView.builder(
                          scrollDirection: Axis.horizontal,
                          shrinkWrap: true,
                          itemCount: character.allSpellsSelected
                              .where((element) => element.level == 6)
                              .toList()
                              .length,
                          itemBuilder: (context, index) {
                            return OutlinedButton(
                              style: OutlinedButton.styleFrom(
                                  backgroundColor: Colors.white),
                              onPressed: () {},
                              child: Text(character.allSpellsSelected
                                  .where((element) => element.level == 6)
                                  .toList()[index]
                                  .name),
                            );
                          },
                        )),
                  if (character.allSpellsSelected
                      .where((element) => element.level == 7)
                      .toList()
                      .isNotEmpty)
                    const Text("Level 7 Spells:"),
                  if (character.allSpellsSelected
                      .where((element) => element.level == 7)
                      .toList()
                      .isNotEmpty)
                    SizedBox(
                        height: 50,
                        child: ListView.builder(
                          scrollDirection: Axis.horizontal,
                          shrinkWrap: true,
                          itemCount: character.allSpellsSelected
                              .where((element) => element.level == 7)
                              .toList()
                              .length,
                          itemBuilder: (context, index) {
                            return OutlinedButton(
                              style: OutlinedButton.styleFrom(
                                  backgroundColor: Colors.white),
                              onPressed: () {},
                              child: Text(character.allSpellsSelected
                                  .where((element) => element.level == 7)
                                  .toList()[index]
                                  .name),
                            );
                          },
                        )),
                  if (character.allSpellsSelected
                      .where((element) => element.level == 8)
                      .toList()
                      .isNotEmpty)
                    const Text("Level 8 Spells:"),
                  if (character.allSpellsSelected
                      .where((element) => element.level == 8)
                      .toList()
                      .isNotEmpty)
                    SizedBox(
                        height: 50,
                        child: ListView.builder(
                          scrollDirection: Axis.horizontal,
                          shrinkWrap: true,
                          itemCount: character.allSpellsSelected
                              .where((element) => element.level == 8)
                              .toList()
                              .length,
                          itemBuilder: (context, index) {
                            return OutlinedButton(
                              style: OutlinedButton.styleFrom(
                                  backgroundColor: Colors.white),
                              onPressed: () {},
                              child: Text(character.allSpellsSelected
                                  .where((element) => element.level == 8)
                                  .toList()[index]
                                  .name),
                            );
                          },
                        )),
                  if (character.allSpellsSelected
                      .where((element) => element.level == 9)
                      .toList()
                      .isNotEmpty)
                    const Text("Level 9 Spells:"),
                  if (character.allSpellsSelected
                      .where((element) => element.level == 9)
                      .toList()
                      .isNotEmpty)
                    SizedBox(
                        height: 50,
                        child: ListView.builder(
                          scrollDirection: Axis.horizontal,
                          shrinkWrap: true,
                          itemCount: character.allSpellsSelected
                              .where((element) => element.level == 9)
                              .toList()
                              .length,
                          itemBuilder: (context, index) {
                            return OutlinedButton(
                              style: OutlinedButton.styleFrom(
                                  backgroundColor: Colors.white),
                              onPressed: () {},
                              child: Text(character.allSpellsSelected
                                  .where((element) => element.level == 9)
                                  .toList()[index]
                                  .name),
                            );
                          },
                        )),
                ])),
                Expanded(
                  child: SingleChildScrollView(child: Column(
                    children: [
                    const SizedBox(height: 20),
                    ...character.allSpellsSelectedAsListsOfThings.map(
                      (s) => SpellSelections(character.allSpellsSelected, s)
                    )
                    ]
                  )),
                )
              ]),
          ]]),
          
          // Equipment Tab
          SingleChildScrollView(
            scrollDirection: Axis.vertical,
            child: Row(children: [
              Expanded(flex: 2, child: SingleChildScrollView(
                scrollDirection: Axis.horizontal,
                child:SizedBox(
                  height: 435,
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.center,
                    children: [
                      /* Title */
                      const SizedBox(height: 9),
                      buildStyledLargeTextBox(text: "Purchase Equipment"),

                      /* Display the characters available money */
                      const SizedBox(height: 6),
                      Text(
                        "You have ${character.currency["Platinum Pieces"]} platinum, ${character.currency["Gold Pieces"]} gold, ${character.currency["Electrum Pieces"]} electrum, ${character.currency["Silver Pieces"]} silver and ${character.currency["Copper Pieces"]} copper pieces to spend",
                        style: TextStyle(fontSize: 18, fontWeight: FontWeight.w700, color: InitialTop.colourScheme.backingColour)
                      ),
                      
                      /* Row of buttons for Armour, Weapons & Items */
                      const SizedBox(height: 6),
                      SizedBox(
                        width: 956,
                        child: Row(children: [

                          /* Buttons for armour. */
                          OutlinedButton(
                            style: OutlinedButton.styleFrom(
                              backgroundColor: (character.armourList.length == 4)
                                ? InitialTop.colourScheme.backingColour
                                : unavailableColor),
                            onPressed: () {
                              setState(() {
                                /* If all types of armour are selected, clear filters. */
                                if (character.armourList.length == 4) {
                                  character.armourList.clear();

                                /* Otherwise add all types of armour to the filters. */
                                } else {
                                  character.armourList = [
                                    "Heavy",
                                    "Light",
                                    "Medium",
                                    "Shield"
                                  ];
                                }
                              });
                            },
                            
                            child: SizedBox(
                              width: 370,
                              height: 63,
                              child: Column(
                                children: [
                                  /* Title */
                                  Text("Armour", style: TextStyle(color: InitialTop.colourScheme.textColour,fontSize: 22)),
                                  Row(
                                    children: [

                                      /* Button to toggle the light armour filter */
                                      makeStyledFilterToggle("Light", character.armourList),

                                      /* Button to toggle the medium armour filter */
                                      makeStyledFilterToggle("Medium", character.armourList),
                                      
                                      /* Button to toggle the Heavy armour filter */
                                      makeStyledFilterToggle("Heavy", character.armourList),

                                      /* Button to toggle the shield filter */
                                      makeStyledFilterToggle("Shield", character.armourList),
                                    ],
                                  )
                                ],
                              )),
                          ),
                          const SizedBox(width: 2),

                          /* Buttons for weapons. */
                          OutlinedButton(
                            style: OutlinedButton.styleFrom(
                              backgroundColor: (character.weaponList.length == 2)
                                ? InitialTop.colourScheme.backingColour
                                : unavailableColor),
                            onPressed: () {
                              setState(() {
                                if (character.weaponList.length == 2) {
                                  character.weaponList.clear();
                                } else {
                                  character.weaponList = ["Ranged", "Melee"];
                                }
                              });
                            },
                            child: SizedBox(
                              width: 192,
                              height: 63,
                              child: Column(
                                children: [
                                  /* Title */
                                  Text("Weapon", style: TextStyle(color: InitialTop.colourScheme.textColour, fontSize: 22)),
                                  Row(
                                    children: [

                                      /* Button to toggle the ranged filter */
                                      makeStyledFilterToggle("Ranged", character.weaponList),

                                      /* Button to toggle the melee filter */
                                      makeStyledFilterToggle("Melee", character.weaponList),
                                    ],
                                  )
                                ],
                              )),
                          ),
                          const SizedBox(width: 2),

                          /* Buttons for items. */
                          OutlinedButton(
                            style: OutlinedButton.styleFrom(
                              backgroundColor:
                                (character.itemList.length == 2)
                                  ? InitialTop.colourScheme.backingColour
                                  : unavailableColor),
                            onPressed: () {
                              setState(() {
                                if (character.itemList.length == 2) {
                                  character.itemList.clear();
                                } else {
                                  character.itemList = [
                                    "Stackable",
                                    "Unstackable"
                                  ];
                                }
                              });
                            },
                            child: SizedBox(
                              width: 246,
                              height: 63,
                              child: Column(
                                children: [
                                  Text("Items", style: TextStyle(color: InitialTop.colourScheme.textColour, fontSize: 22)),
                                  Row(
                                    children: [

                                      /* Button to toggle the stackable filter */
                                      makeStyledFilterToggle("Stackable", character.itemList),

                                      /* Button to toggle the unstackable filter */
                                      makeStyledFilterToggle("Unstackable", character.itemList),
                                    ],
                                  )
                                ],
                              )),
                          ),
                        ]),
                      ),
                      const SizedBox(height: 4),

                      /* Buttons for costs. */
                      OutlinedButton(
                        style: OutlinedButton.styleFrom(
                          backgroundColor: (coinTypesSelected.length == 5)
                            ? InitialTop.colourScheme.backingColour
                            : unavailableColor),
                        onPressed: () {
                          setState(() {
                            /* If all types of armour are selected, clear filters. */
                            if (coinTypesSelected.length == 5) {
                              coinTypesSelected.clear();

                            /* Otherwise add all types of armour to the filters. */
                            } else {
                              coinTypesSelected = [
                                "Platinum",
                                "Gold",
                                "Electrum",
                                "Silver",
                                "Copper"
                              ];
                            }
                          });
                        },
                        child: SizedBox(
                          width: 483,
                          height: 63,
                          child: Column(
                            children: [
                              /* Title */
                              Text("Coin types", style: TextStyle(color: InitialTop.colourScheme.textColour, fontSize: 22)),
                              Row(
                                children: [

                                  /* Button to select items that cost platinum. */
                                  makeStyledFilterToggle("Platinum", coinTypesSelected),

                                  /* Button to select items that cost gold. */
                                  makeStyledFilterToggle("Gold", coinTypesSelected),

                                  /* Button to select items that cost electrum. */
                                  makeStyledFilterToggle("Electrum", coinTypesSelected),

                                  /* Button to select items that cost silver. */
                                  makeStyledFilterToggle("Silver", coinTypesSelected),

                                  /* Button to select items that cost copper. */
                                  makeStyledFilterToggle("Copper", coinTypesSelected)
                                ],
                              )
                            ],
                          )),
                      ),

                      /* Display the filtered items */
                      const SizedBox(height: 4),
                      Container(
                          padding: const EdgeInsets.only(top: 10),
                          decoration: BoxDecoration(
                            color: InitialTop.colourScheme.backgroundColour,
                            border: Border.all(color: Colors.black, width: 1.6),
                            borderRadius: const BorderRadius.all(Radius.circular(5))
                          ),
                          height: 200,
                          width: 600,
                          child: SingleChildScrollView(
                            scrollDirection: Axis.vertical,
                            child: Wrap(
                              spacing: 8.0,
                              runSpacing: 8.0,
                              alignment: WrapAlignment.center,
                              children: List.generate(filteredItems.length, (index) {
                                return OutlinedButton(
                                  style: OutlinedButton.styleFrom(backgroundColor: InitialTop.colourScheme.backingColour),

                                  /* If the character has enough money of the correct denomination than the purchase is made. */
                                  onPressed: () {
                                    setState(() {
                                      if (filteredItems[index].cost[0] <= character.currency["${filteredItems[index].cost[1]} Pieces"]) {
                                        character.currency["${filteredItems[index].cost[1]} Pieces"] = 
                                          character.currency["${filteredItems[index].cost[1]} Pieces"]! - (filteredItems[index].cost[0] as int);
                                        if (filteredItems[index]
                                            .stackable) {
                                          if (character.stackableEquipmentSelected.containsKey(filteredItems[index].name)) {
                                            character.stackableEquipmentSelected[filteredItems[index].name] = character.stackableEquipmentSelected[filteredItems[index].name]! +1;
                                          } else {
                                            character.stackableEquipmentSelected[filteredItems[index].name] = 1;
                                          }
                                        } else {
                                          character.unstackableEquipmentSelected.add(filteredItems[index]);
                                        }
                                      }
                                    });
                                  },

                                  /* Item name and price. */
                                  child: Text(
                                    "${filteredItems[index].name}: ${filteredItems[index].cost[0]}x${filteredItems[index].cost[1]}",
                                    style: TextStyle(color: InitialTop.colourScheme.textColour)),
                                );
                              }),
                            )))
                    ])))),

            /* Selection of item options from class and background */
            Expanded(
                child: SizedBox(
                    height: 435,
                    child: Column(
                      children: [
                        /* Title */
                        const SizedBox(height: 9),
                        buildStyledMediumTextBox(text: "Choose equipment from options gained:"),
                        const SizedBox(height: 6),

                        /* A column containing each choice as a pair of buttons */
                        (character.equipmentSelectedFromChoices.isEmpty) 
                          ? buildStyledSmallTextBox(text: "No equipment choices available")
                          : SizedBox(
                            height: 300,
                            child: SingleChildScrollView(
                              child: Column(
                                children: [
                                  for (var i = 0; i < character.equipmentSelectedFromChoices.length; i++) 
                                    (character.equipmentSelectedFromChoices[i].length == 2)
                                      ? SingleChildScrollView(
                                          scrollDirection: Axis.horizontal,
                                          child: Row(children: [

                                            /* Button for the first option */
                                            ElevatedButton(
                                              style: OutlinedButton.styleFrom(backgroundColor: InitialTop.colourScheme.backingColour),
                                              onPressed: () {
                                                setState(() {
                                                  character.equipmentSelectedFromChoices[i] = [character.equipmentSelectedFromChoices[i][0]];
                                                });
                                              },
                                              child: Text(
                                                produceEquipmentOptionDescription(character.equipmentSelectedFromChoices[i][0]),
                                                style: TextStyle(color: InitialTop.colourScheme.textColour)
                                              ),
                                            ),

                                            /* Button for the second option */
                                            ElevatedButton(
                                              style: OutlinedButton.styleFrom(backgroundColor: InitialTop.colourScheme.backingColour),
                                              onPressed: () {
                                                setState(() {
                                                  character.equipmentSelectedFromChoices[i] = [character.equipmentSelectedFromChoices[i][1]];
                                                });
                                              },
                                              child: Text(
                                                produceEquipmentOptionDescription(character.equipmentSelectedFromChoices[i][1]),
                                                style: TextStyle(color: InitialTop.colourScheme.textColour)
                                              ),
                                            )
                                          ],
                                        ),
                                      )
                                    : Text(
                                        produceEquipmentOptionDescription(character.equipmentSelectedFromChoices[i][0]),
                                        style: TextStyle(color: InitialTop.colourScheme.backingColour, fontWeight: FontWeight.w700)
                                      ),
                                ],
                              ),
                            ),
                          )
                      ],
                    ))),
            ],
          )),
          
          // Backstory Tab
          SingleChildScrollView(
              scrollDirection: Axis.vertical,
              child: Column(children: [
                // Character Description
                const SizedBox(height: 20, width: 10),
                buildStyledHugeTextBox(text: "Character Information:"),
                const SizedBox(height: 10, width: 10),
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    // Age and Eyes
                    Column(
                      children: [
                        buildStyledMediumTextBox(text: "Age:"),
                        const SizedBox(height: 10),
                        buildStyledSmallTextField(
                        hintText: "Enter character's age", 
                        textController: ageEnterController, 
                        onChanged:(characterAgeEnteredValue) {
                            setState(() {
                              character.characterDescription.age = characterAgeEnteredValue;
                            });
                          }
                        ),
                        const SizedBox(height: 10),

                        buildStyledMediumTextBox(text: "Eyes:"),
                        const SizedBox(height: 10),
                        buildStyledSmallTextField(
                        hintText: "Describe your character's eyes", 
                        textController: eyeColourController, 
                        onChanged:(characterEyeEnteredValue) {
                            setState(() {
                              character.characterDescription.eyes = characterEyeEnteredValue;
                            });
                          }
                        ),
                      ],
                    ),
                    const SizedBox(width: 10, height: 100),

                    // Height and Skin
                    Column(
                      children: [
                        buildStyledMediumTextBox(text: "Height:"),
                        const SizedBox(height: 10),
                        buildStyledSmallTextField(
                        hintText: "Enter character's height", 
                        textController: heightEnterController, 
                        onChanged:(characterHeightEnteredValue) {
                            setState(() {
                              character.characterDescription.height = characterHeightEnteredValue;
                            });
                          }
                        ),
                        const SizedBox(height: 10),

                        buildStyledMediumTextBox(text: "Skin:"),
                        const SizedBox(height: 10),
                        buildStyledSmallTextField(
                        hintText: "Describe your character's skin", 
                        textController: skinEnterController, 
                        onChanged:(characterSkinEnteredValue) {
                            setState(() {
                              character.characterDescription.skin = characterSkinEnteredValue;
                            });
                          }
                        ),
                      ],
                    ),
                    const SizedBox(width: 10, height: 100),

                    // Weight and Hair
                    Column(
                      children: [
                        buildStyledMediumTextBox(text: "Weight:"),
                        const SizedBox(height: 10),
                        buildStyledSmallTextField(
                        hintText: "Enter character's weight", 
                        textController: weightEnterController, 
                        onChanged:(characterWeightEnteredValue) {
                            setState(() {
                              character.characterDescription.weight = characterWeightEnteredValue;
                            });
                          }
                        ),
                        const SizedBox(height: 10),

                        buildStyledMediumTextBox(text: "Hair:"),
                        const SizedBox(height: 10),
                        buildStyledSmallTextField(
                        hintText: "Describe your character's hair", 
                        textController: hairEnterController, 
                        onChanged:(characterHairEnteredValue) {
                            setState(() {
                              character.characterDescription.hair = characterHairEnteredValue;
                            });
                          }
                        ),
                      ],
                    )
                  ],
                ),

                // Character Backstory
                buildStyledHugeTextBox(text: "Backstory:"),
                const SizedBox(height: 5),
                buildStyledLargeTextField(
                  hintText: 
                    "Write out your character's backstory. This should be a description of their past, including but not limited to: Who raised them/ how were they raised, any serious traumas or achievements in their life and then linking to justify your/ having another, reason for being in the campaign.",
                  textController: backstoryEnterController,
                  onChanged: (backstoryEnteredValue) {
                    setState(() {
                      character.characterDescription.backstory = backstoryEnteredValue;
                    });
                  }
                ),

                // Additional Features
                buildStyledHugeTextBox(text: "Additional Features:"),
                const SizedBox(height: 5),
                buildStyledLargeTextField(
                  hintText: 
                    "Write any additional features, skills or abilities which are not a part of the character's race/class/background etc. These should have been agreed apon by your DM or whoever is running the game.",
                  textController: additionalFeaturesEnterController,
                  onChanged: (extraFeaturesEnteredValue) {
                    setState(() {
                      character.extraFeatures = extraFeaturesEnteredValue;
                    });
                  }
                ),
              ])),
          
          // Finishing Up Tab
          Scaffold(
              backgroundColor: InitialTop.colourScheme.backgroundColour,
              // Floating pdf generator button
              floatingActionButton: FloatingActionButton(
                tooltip: "Generate a PDF",
                foregroundColor: InitialTop.colourScheme.textColour,
                backgroundColor: InitialTop.colourScheme.backingColour,
                onPressed: () {
                  Navigator.of(context).push(
                    MaterialPageRoute(
                      builder: (context) => PdfPreviewPage(
                          character: character),
                    ),
                  );
                },
                child: const Icon(Icons.picture_as_pdf),
              ),
              body:
                Row(crossAxisAlignment: CrossAxisAlignment.center, children: [
                  const Expanded(child: SizedBox()),
                  Expanded(
                      flex: 5,
                      child: Column(
                          crossAxisAlignment: CrossAxisAlignment.center,
                          children: [
                            const SizedBox(height: 40),
                            buildStyledHugeTextBox(text: "Add your character to a group:"),
                            const SizedBox(height: 20),
                            buildStyledMediumTextBox(text: "Select an existing group:"),
                            const SizedBox(height: 20),
                            // Group selection dropdown and input field
                            Container(
                              decoration: BoxDecoration(
                                borderRadius:
                                    const BorderRadius.all(Radius.circular(5)),
                                color: (GROUPLIST.isNotEmpty)
                                    ? InitialTop.colourScheme.backingColour
                                    : const Color.fromARGB(247, 56, 53, 52),
                              ),
                              height: 45,
                              child: buildBaseDropdownButton(
                                value: GROUPLIST.contains(character.group) ? character.group : null, 
                                items: GROUPLIST.isNotEmpty ? GROUPLIST : null, 
                                onChanged: (String? value) {
                                  setState(() {
                                    character.group = value!;
                                  });
                                },
                                hintText: (GROUPLIST.isNotEmpty) ? " No matching group selected " : " No groups available "
                            )),
                            const SizedBox(height: 20),
                            buildStyledMediumTextBox(text: "Or create a new one:"),
                            const SizedBox(height: 20),
                            buildStyledSmallTextField(
                              width: 300,
                              hintText: "Enter a group",
                              textController: groupEnterController,
                              onChanged: (groupNameEnteredValue) {
                                setState(() {
                                  character.group = groupNameEnteredValue;
                                });
                              }
                            ),
                            const SizedBox(height: 30),
                            // Character save button
                            Tooltip(
                                message: canCreateCharacter? "This button will save your character putting it into the Json and then send you back to the main menu.": "You must complete the required tabs before saving your character",
                                child: ElevatedButton(
                                  style: OutlinedButton.styleFrom(
                                    backgroundColor: canCreateCharacter ? InitialTop.colourScheme.backingColour : unavailableColor,
                                    padding: const EdgeInsets.fromLTRB(45, 20, 45, 20),
                                    shape: const RoundedRectangleBorder(
                                        borderRadius: BorderRadius.all(
                                            Radius.circular(10))),
                                    side: const BorderSide(width: 3, color: Colors.black),
                                  ),
                                  child: buildStyledHugeTextBox(text: "Save Character", color: InitialTop.colourScheme.textColour),
                                  onPressed: () {
                                    if (canCreateCharacter) {
                                      setState(() {
                                        CHARACTERLIST.add(character);
                                        if ((!GROUPLIST.contains(character.group)) &&
                                            character.group != null &&
                                            character.group!.replaceAll(" ", "") != "") {
                                          GROUPLIST.add(character.group!);
                                        }
                                        saveChanges();
                                        Navigator.pop(context);
                                        Navigator.push(
                                          context,
                                          MaterialPageRoute(
                                              builder: (context) => InitialTop()),
                                        );
                                        showCongratulationsDialog(context);
                                      });
                                    }
                                  },
                                ))
                          ])),
                Expanded(
                    flex: 7,
                    child: Column(children: [
                      const SizedBox(height: 40),
                      buildStyledHugeTextBox(text: "Build checklist:"),
                      
                      //Basics
                      const SizedBox(height: 20),
                      makeOptionalText(condition: character.basicsComplete, trueText: "Filled in all basic information", falseText: "Haven't filled in all necessary basics"),

                      //Ability Scores
                      const SizedBox(height: 20),
                      makeRequiredText(condition: (pointsRemaining == 0), trueText: "Used all ability score points", falseText: "$pointsRemaining unspent ability score points"),
                      
                      //ASI+feats
                      const SizedBox(height: 20),
                      (numberOfRemainingFeatOrASIs == 0)
                        ? makeRequiredText(
                            condition: !remainingAsi, 
                            trueText: "Made all ASI/Feats selections", 
                            falseText: "You have an unused ASI"
                          )
                        : buildStyledMediumTextBox(
                          text: "You have $numberOfRemainingFeatOrASIs ASI/Feat (s) remaining", 
                          color: negativeColor
                          ),

                      //Class
                      const SizedBox(height: 20),
                      makeRequiredText(
                        condition: (charLevel <= character.classList.length),
                        trueText: "Made all level selections", 
                        falseText: "${charLevel - character.classList.length} unused level${(charLevel > 1)? "s":""}"
                      ),

                      //Equipment
                      const SizedBox(height: 20),
                      makeRequiredText(
                        condition: character.chosenAllEqipment,
                        trueText: "Made all equipment selections", 
                        falseText: "Missed ${character.equipmentSelectedFromChoices.where((element) => element.length == 2).toList().length} equipment choice(s)"
                      ),
                      
                      const SizedBox(height: 20),
                      // Spells
                      makeRequiredText(
                        condition: character.chosenAllSpells,
                        trueText: "Made all spells selections", 
                        falseText: "Missed ${(character.allSpellsSelectedAsListsOfThings.fold(0, (a, b) => a + (b[2] as int)))} spells"),                            

                      // Backstory
                      const SizedBox(height: 20),
                      makeOptionalText(
                        condition: character.backstoryComplete,
                         trueText: "Completed backstory", 
                         falseText: "Haven't filled in all backstory information"
                      )
                ]))
              ])),
        ]),
      ),
    );});
  }

  Tab tabLabel(String label) {
    return Tab(child: Text(label, style: TextStyle(color: InitialTop.colourScheme.textColour)));
  }

  /* Used in: Basics */
  Container buildSectionHeader(String title) {
    return Container(
      width: 330,
      height: 65,
      decoration: BoxDecoration(
        color: InitialTop.colourScheme.backingColour,
        border: Border.all(color: Colors.black, width: 2.1),
        borderRadius: const BorderRadius.all(Radius.circular(5)),
      ),
      child: Center(
        child: Text(
          title,
          textAlign: TextAlign.center,
          style: TextStyle(
            fontSize: 35,
            fontWeight: FontWeight.w700,
            color: InitialTop.colourScheme.textColour,
          ),
        ),
      ),
    );
  }

  /* Used in: Basics */
  CheckboxListTile buildStyledCheckboxListTile({
    required String title,
    required bool? value,
    required ValueChanged<bool?> onChanged,
  }) {
    return CheckboxListTile(
      title: Text(title, style: TextStyle(color: InitialTop.colourScheme.backingColour)),
      value: value,
      onChanged: onChanged,
      activeColor: InitialTop.colourScheme.backingColour,
      secondary: Icon(Icons.insert_photo, color: InitialTop.colourScheme.backingColour),
    );
  }

  /* Used in: Basics */
  RadioListTile buildStyledRadioListTile({
    required String title,
    required String value,
    required String? groupValue,
    required ValueChanged<dynamic> onChanged,
  }) {
    return RadioListTile(
      activeColor: InitialTop.colourScheme.backingColour,
      title: Text(title,
          style: TextStyle(
              color:
                  InitialTop.colourScheme.backingColour)),
      value: value,
      groupValue: groupValue,
      onChanged: onChanged,
    );
  }

  /* Helper function */
  TextField buildStyledTextField({
    required String hintText,
    required TextEditingController textController,
    required ValueChanged<String> onChanged,
    required Color textColor,
    required Color backingColor,
    int lineMax = 1,
    int? lineMin,
    bool filled = false,
  }) {
    return TextField(
      controller: textController,
      maxLines: lineMax,
      minLines: lineMin,
      cursorColor: textColor,
      style: TextStyle(
          fontWeight: FontWeight.w700,
          color: textColor),
      decoration: InputDecoration(
          hintText: hintText,
          hintStyle: TextStyle(
              fontWeight: FontWeight.w700,
              color: textColor),
          filled: filled,
          fillColor: backingColor,
          border: OutlineInputBorder(
              borderSide:
                  BorderSide(color: backingColor),
              borderRadius:
                  const BorderRadius.all(Radius.circular(12)))),
      onChanged: onChanged
    );
  }
  
  /* Used in: Basics, Backstory */
  SizedBox buildStyledSmallTextField({
    required String hintText,
    required TextEditingController textController,
    required ValueChanged<String> onChanged,
    double width = 250
  }) {
    return SizedBox(
      width: width,
      height: 50,
      child: buildStyledTextField(
        backingColor: InitialTop.colourScheme.backingColour,
        textColor: InitialTop.colourScheme.textColour, 
        textController: textController, 
        hintText: hintText, 
        onChanged: onChanged, 
        filled: true
      )
    );
  }

  /* Used in: Basics, Backstory */
  SizedBox buildStyledLargeTextField({
    required String hintText,
    required TextEditingController textController,
    required ValueChanged<String> onChanged,
  }) {
    return SizedBox(
      width: 1000,
      height: 100,
      child: buildStyledTextField(
        hintText: hintText, 
        textController: textController, 
        onChanged: onChanged,
        textColor: InitialTop.colourScheme.backingColour, 
        backingColor: InitialTop.colourScheme.backingColour,
        lineMax: 100,
        lineMin: 4
      )
    );
  }

  /* Used in: Race */
  Text buildStyledTextBox({
    required String text,
    required double size,
    Color? color,
  }) {
    return Text(text,
      style: TextStyle(
        color: color ?? InitialTop.colourScheme.backingColour,
        fontSize: size,
        fontWeight: FontWeight.w700));
  }

    /* Used in: Race */
  Text buildStyledTinyTextBox({
    required String text,
    Color? color
  }) {
    return buildStyledTextBox(text: text, size: 15, color: color);
  }
  
  /* Used in: Race */
  Text buildStyledSmallTextBox({
    required String text,
    Color? color
  }) {
    return buildStyledTextBox(text: text, size: 20, color: color);
  }

  /* Used in: Race */
  Text buildStyledMediumTextBox({
    required String text,
    Color? color
  }) {
    return buildStyledTextBox(text: text, size: 25, color: color);
  }

    /* Used in:  */
  Text buildStyledLargeTextBox({
    required String text,
    Color? color
  }) {
    return buildStyledTextBox(text: text, size: 30, color: color);
  }

  /* Used in:  */
  Text buildStyledHugeTextBox({
    required String text,
    Color? color
  }) {
    return buildStyledTextBox(text: text, size: 35, color: color);
  }

  /* Helper function */
  DropdownButton<String> buildBaseDropdownButton({
  required String? value,
  required List<String>? items,
  required ValueChanged<String?> onChanged,
  String hintText = "Select an option"
  }) {
    return DropdownButton<String>(
      alignment: Alignment.center,
      dropdownColor: InitialTop.colourScheme.backingColour,
      hint: Center(
        child: Text(
          hintText,
          textAlign: TextAlign.center,
            style: TextStyle(
              color: InitialTop.colourScheme.textColour,
              decoration: TextDecoration.underline,
            ),
      )),
      value: value,
      underline: SizedBox(),
      icon: Icon(Icons.arrow_drop_down, color: InitialTop.colourScheme.textColour,),
      style: TextStyle(
        color: InitialTop.colourScheme.textColour,
        fontWeight: FontWeight.w700,
      ),
      onChanged: onChanged,
      items: items?.map<DropdownMenuItem<String>>((String itemValue) {
        return DropdownMenuItem<String>(
          value: itemValue,
          child: Align(
            child: Text(
              itemValue,
              textAlign: TextAlign.center,
              style: TextStyle(
                color: InitialTop.colourScheme.textColour,
                decoration: TextDecoration.underline,
              ),
            ),
          ),
        );
      }).toList(),
    );
  }


  /* Used in: Races, Background */
  Container buildStyledDropDown({
    required String? initialValue,
    required List<Content>? items,
    required ValueChanged<String?> onChanged,
  }) {
    final itemNames = items?.map((e) => e.name).toList() ?? [];
    return Container(
      decoration: BoxDecoration(
        borderRadius: const BorderRadius.all(Radius.circular(5)),
        color: InitialTop.colourScheme.backingColour,
      ),
      height: 45,
      child: buildBaseDropdownButton(value: initialValue, items: itemNames, onChanged: onChanged)
    );
  }

  /*Used in Background
  Takes a title and items (List<String>) and creates a dropdown of the items with the title given */
  Widget buildLabeledDropdown({
    required String labelText,
    required String? selectedValue,
    required List<String> items,
    required ValueChanged<String?> onChanged,
  }) {
    return Column(
      children: [
        const SizedBox(height: 10),
        buildStyledSmallTextBox(text: labelText),
        const SizedBox(height: 8),
        Container(
          decoration: BoxDecoration(
            borderRadius: const BorderRadius.all(Radius.circular(5)),
            color: InitialTop.colourScheme.backingColour,
          ),
          height: 45,
          child: buildBaseDropdownButton(value: selectedValue, items: items, onChanged: onChanged),
        ),
      ],
    );
  }

  /* Used in: Races, Background */
  ToggleButtons buildStyledToggleSelector({
  required List<bool> isSelected,
  required void Function(int index, bool currentlySelected) onPressed,
  required List<String> itemLabels,
  }) {
    return ToggleButtons(
      selectedColor: InitialTop.colourScheme.textColour,
      color: InitialTop.colourScheme.backingColour,
      fillColor: InitialTop.colourScheme.backingColour,
      textStyle: const TextStyle(
      fontSize: 22,
      fontWeight: FontWeight.w700,
    ),
      borderColor: InitialTop.colourScheme.backingColour,
      borderRadius: const BorderRadius.all(Radius.circular(20)),
      borderWidth: 1.5,
      onPressed: (int index) {
        bool currentlySelected = isSelected[index];
        onPressed(index, currentlySelected);
      },
      isSelected: isSelected,
      children: itemLabels.map((label) => Text(" $label ")).toList(),
    );
        
  }

  /* Used in: Races */
  SizedBox buildNStyledAsiSelectors({
    required int numbItems,
    required void Function(int choiceNumber, int index, bool isSelected) onPressed,
    required List<List<bool>> optionalStates,
  }) {
    assert(numbItems <= optionalStates.length, 
    "itemCount should not exceed the length of optionalStates");
    assert(numbItems >= 0, 
    "itemCount should not be negative");
    return SizedBox(
      height:  numbItems * 62 - 10,
      child: ListView.separated(
        itemCount: numbItems,
        separatorBuilder: (BuildContext context, int index) =>
          Divider(height: 10.0, color: InitialTop.colourScheme.backgroundColour),
        itemBuilder: (BuildContext context, int choiceNumber) {
          return Align(
            alignment: Alignment.center,
            child: buildStyledToggleSelector(
              isSelected: optionalStates[choiceNumber],
              onPressed: (index, currentlySelected) {
                onPressed(choiceNumber, index, currentlySelected);
              },
              itemLabels: abilityScores
            )  
          );
        },
      )
    );
  }

  /* Used in: Ability score */
  Column buildAbilityScoreBlock({
    required AbilityScore score,
  }) {
    
    // Increment/decrement logic helper methods
    void decrementScore() {
      if (score.value > 8) {
        score.value--;
        pointsRemaining += abilityScoreCost(score.value);
      }
    }

    void incrementScore() {
      if (score.value < 15) {
        final cost = abilityScoreCost(score.value);
        if (cost <= pointsRemaining) {
          pointsRemaining -= cost;
          score.value ++;
        }
      }
    }

    bool canAdd = score.value < 15;
    bool canRemove = 8 < score.value;
    int index = abilityScores.indexOf(score.name);

    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        // Name
        buildStyledHugeTextBox(text: score.name),
        const SizedBox(height: 25),

        // Base value & increment/decrement buttons
        Container(
          height: 128.2,
          width: 135.2,
          decoration: BoxDecoration(
            color: InitialTop.colourScheme.backingColour,
            border: Border.all(color: Colors.black, width: 1.6),
            borderRadius: const BorderRadius.all(Radius.circular(5)),
          ),
          child: Column(
            children: [
              // Current Value
              Text(
                textAlign: TextAlign.center,
                "${score.value}",
                style: TextStyle(
                    fontSize: 65,
                    fontWeight: FontWeight.w700,
                    color: InitialTop.colourScheme.textColour),
              ),
              Row(
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                  // If only one button available, centre it
                  if (!canAdd || !canRemove)
                    const SizedBox(height: 20, width: 33.8),

                  // Decrement Button
                  if (canRemove)
                    OutlinedButton(
                      style: OutlinedButton.styleFrom(
                        backgroundColor: InitialTop.colourScheme.backingColour,
                        shape: const RoundedRectangleBorder(
                          borderRadius: BorderRadius.all(Radius.circular(4)),
                        ),
                        side: const BorderSide(
                          width: 3,
                          color: negativeColor,
                        ),
                      ),
                      onPressed: () {
                        setState(() {
                          decrementScore();
                        });
                      },
                      child: const Icon(Icons.remove, color: Colors.white),
                    ),

                  // Increment Button
                  if (canAdd)
                    OutlinedButton(
                      style: OutlinedButton.styleFrom(
                        backgroundColor:
                            (abilityScoreCost(score.value) > pointsRemaining)
                                ? unavailableColor 
                                : InitialTop.colourScheme.backingColour,
                        shape: const RoundedRectangleBorder(
                          borderRadius: BorderRadius.all(Radius.circular(4)),
                        ),
                        side: const BorderSide(
                          width: 3,
                          color: positiveColor,
                        ),
                      ),
                      onPressed: () {
                        setState(() {
                          incrementScore();
                        });
                      },
                      child: const Icon(Icons.add, color: Colors.white),
                    )
                ],
              ),
            ],
          ),
        ),

        const SizedBox(height: 10),

        // Race and Feat Increases
        Row(
        crossAxisAlignment: CrossAxisAlignment.center, 
        children: [
          const SizedBox(width: 19),
          Text(
            textAlign: TextAlign.center,
            " (+${character.raceAbilityScoreIncreases[index]}) ",
            style: const TextStyle(
              fontSize: 25,
              fontWeight: FontWeight.w700,
              color: Colors.black,
            ),
          ),
          Text(
            textAlign: TextAlign.center,
            " (+${character.featsASIScoreIncreases[index]}) ",
            style: TextStyle(
              fontSize: 25,
              fontWeight: FontWeight.w700,
              color: InitialTop.colourScheme.backingColour,
            ),
          ),
        ]),

        const SizedBox(height: 10),

        // Final displayed total
        Container(
          width: 90,
          height: 80,
          decoration: BoxDecoration(
            color: InitialTop.colourScheme.backingColour,
            border: Border.all(color: Colors.black, width: 1.6),
            borderRadius: const BorderRadius.all(Radius.circular(5)),
          ),
          child: Text(
            (score.value + character.raceAbilityScoreIncreases[index] + character.featsASIScoreIncreases[index]).toString(),
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 50,
              fontWeight: FontWeight.w700,
              color: InitialTop.colourScheme.textColour,
            ),
          ),
        ),
      ],
    );
  }

  /* Used in: Finishing up */
  Text makePossibleText({
    required Color colorFalse,
    required bool condition,
    required String trueText,
    required String falseText,
  }) {
    return buildStyledMediumTextBox(
      text: condition ? trueText : falseText, 
      color: condition ? positiveColor : colorFalse
    );
  }

  Container buildAsiBlock({
    required AbilityScore score,
  }) {
    int index = abilityScores.indexOf(score.name);
    bool scoreBelowMax = (score.value + character.featsASIScoreIncreases[index] < 20);
    return Container(
      height: 136,
      width: 160,
      decoration: BoxDecoration(
        color: InitialTop.colourScheme.backingColour,
        border: Border.all(color: Colors.black, width: 1.6),
        borderRadius: const BorderRadius.all(
          Radius.circular(5)
        ),
      ),
      child: Column(children: [
        buildStyledMediumTextBox(text: score.name, color: InitialTop.colourScheme.textColour),
        buildStyledTextBox(text: "+${character.featsASIScoreIncreases[index]}", size: 45, color: InitialTop.colourScheme.textColour),
        OutlinedButton(
            style: OutlinedButton.styleFrom(
              backgroundColor: ((!remainingAsi && numberOfRemainingFeatOrASIs == 0) || !(scoreBelowMax))
                ? unavailableColor
                : InitialTop.colourScheme.backingColour,
              shape: const RoundedRectangleBorder(
                  borderRadius: BorderRadius.all(Radius.circular(4))
                ),
              side: const BorderSide(width: 3, color: positiveColor),
            ),
            onPressed: () {
              setState(() {
                if (scoreBelowMax) {
                  if (remainingAsi) {
                    remainingAsi = false;
                    character.featsASIScoreIncreases[index] ++;
                  } else if (numberOfRemainingFeatOrASIs > 0) {
                    numberOfRemainingFeatOrASIs --;
                    remainingAsi = true;
                    character.featsASIScoreIncreases[index] ++;
                  }
                }
              });
            },
            child: const Icon(Icons.add, color: Colors.white, size: 32)),
      ]),
    );
  }

  SizedBox buildAsiBlockRow ({
    required AbilityScore scoreLeft,
    required AbilityScore scoreRight,
  }) {
    return SizedBox(
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          buildAsiBlock(score: scoreLeft),
          const SizedBox(width: 10),
          buildAsiBlock(score: scoreRight),
        ],
      )
    );
  }

  OutlinedButton buildBinarySelectorButton({
    required String key
  }) {
    assert(featFilters.containsKey(key), "Key must be a valid key in featFilters");
    return OutlinedButton(
      style: OutlinedButton.styleFrom(
        backgroundColor: (featFilters[key]!) ? InitialTop.colourScheme.backingColour : unavailableColor),
      onPressed: () {
        setState(() {
          featFilters[key] = !featFilters[key]!;
        });
      },
      child: buildStyledTinyTextBox(text: key, color: InitialTop.colourScheme.textColour)
    );
  }

  Text makeRequiredText({
    required bool condition,
    required String trueText,
    required String falseText,
  }) {
    return makePossibleText(
      colorFalse: negativeColor, 
      condition: condition, 
      trueText: trueText, 
      falseText: falseText
    );
  }

  Text makeOptionalText({
    required bool condition,
    required String trueText,
    required String falseText,
  }) {
    return makePossibleText(
      colorFalse: notIdealColor, 
      condition: condition, 
      trueText: trueText, 
      falseText: falseText
    );
  }

  ElevatedButton makeStyledFilterToggle(String label, List<String> filters) {
    return ElevatedButton(
      style: OutlinedButton.styleFrom(
        backgroundColor: (filters.contains(label)) ? InitialTop.colourScheme.backingColour : unavailableColor
      ),
      onPressed: () {
        setState(() {
          if (filters.contains(label)) {
            filters.remove(label);
          } else {
            filters.add(label);
          }
        });
      },
      child: Text(label, style: TextStyle(color: InitialTop.colourScheme.textColour, fontSize: 15))
    );
  }

  void showCongratulationsDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        content: const Text('Character created!',
            style: TextStyle(
                color: Colors.green,
                fontSize: 50,
                fontWeight: FontWeight.w800)),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
            },
            child: const Text('Continue'),
          ),
        ],
      ),
    );
  }

  bool scoresFailRequirement(Character character, List<int> requirements) {
    int count = 0;
    if (character.strength.value + character.raceAbilityScoreIncreases[0] + character.featsASIScoreIncreases[0] >= requirements[0]) count++;
    if (character.dexterity.value + character.raceAbilityScoreIncreases[1] + character.featsASIScoreIncreases[1] >= requirements[1]) count++;
    if (character.constitution.value + character.raceAbilityScoreIncreases[2] + character.featsASIScoreIncreases[2] >= requirements[2]) count++;
    if (character.intelligence.value + character.raceAbilityScoreIncreases[3] + character.featsASIScoreIncreases[3] >= requirements[3]) count++;
    if (character.wisdom.value + character.raceAbilityScoreIncreases[4] + character.featsASIScoreIncreases[4] >= requirements[4]) count++;
    if (character.charisma.value + character.raceAbilityScoreIncreases[5] + character.featsASIScoreIncreases[5] >= requirements[5]) count++;

    return count >= requirements[6];
  }
  
  bool multiclassingPossible(Class selectedClass) {
    // Check if it is their first class or they already have a level in the class
    if (character.classList.isEmpty || character.classList.contains(selectedClass.name)) {
      return true;
    }

    // Check if multiclassing is allowed
    if (!(character.multiclassing ?? false)) {
      return false;
    }

    // Check they satisfy the class they want to take
    if (scoresFailRequirement(character, selectedClass.multiclassingRequirements)) {
      return false;
    }

    // Check they satisfy their last added class's requirements
    return scoresFailRequirement(character, CLASSLIST.last.multiclassingRequirements);
  }

  Widget? levelGainParser(List<dynamic> x, Class selectedClass) {
    //Levelup(class?)
    if (x[0] == "Level") {
      // ("Level", "numb")
      return Text(
        "${selectedClass.name} Level ${x[1]} choice(s):",
        style: const TextStyle(
            fontSize: 25,
            fontWeight: FontWeight.w700,
            color: Color.fromARGB(255, 0, 168, 252)),
      );
    } else if (x[0] == "Nothing") {
      // ("Nothing", "numb")
      return Text(
        "No choices needed for ${selectedClass.name} level ${x[1]}",
        style: const TextStyle(
            fontSize: 25,
            fontWeight: FontWeight.w700,
            color: Color.fromARGB(255, 0, 168, 252)),
      );
    } else if (x[0] == "Bonus") {
      // ("Bonus","String description")
      character.featuresAndTraits.add("${x[1]}: ${x[2]}");
    } else if (x[0] == "AC") {
      // ("AC","intelligence + 2", "RQUIREMENT")
      character.ACList.add([x[1], x[2]]);
    } else if (x[0] == "Speed") {
      //note base speed is given by race
      //("speed", (w/s/c/f/h), numb/expression")
      character.speedBonuses[x[1]]?.add(x[2]);
    } else if (x[0] == "AttributeBoost") {
      if (x[1] == "Intelligence") {
        character.intelligence.value += int.parse(x[2]);
      } else if (x[1] == "Strength") {
        character.strength.value += int.parse(x[2]);
      } else if (x[1] == "Constitution") {
        character.constitution.value += int.parse(x[2]);
      } else if (x[1] == "Dexterity") {
        character.dexterity.value += int.parse(x[2]);
      } else if (x[1] == "Wisdom") {
        character.wisdom.value += int.parse(x[2]);
      } else if (x[1] == "charisma") {
        character.charisma.value += int.parse(x[2]);
      }
      //do this later
    } else if (x[0] == "Gained") {
      character.skillBonusMap[x[1]] = character.skillBonusMap[x[1]]! + int.parse(x[2]);
      //do this later
    } else if (x[0] == "ASI") {
      numberOfRemainingFeatOrASIs++;
    }
    //FUTUREPLAN(Implement further parsing for: proficiencies, languages, equipment )

    /*else if (x[0] == "Equipment") {
    //note base speed is given by race
    //("speed", "10", "(w/s/c/f)")
    SPEEDLIST.append([x[1], x[2]]);
  }*/
    else if (x[0] == "Money") {
      //("Money", "Copper Pieces", "10")
      character.currency[x[1]] = character.currency[x[1]]! + int.parse(x[2]);
    }
    return null;
  }

  int levelZeroGetSpellsKnown(int index) {
    if (CLASSLIST[index].spellsKnownFormula == null) {
      return CLASSLIST[index].spellsKnownPerLevel![character.classLevels[index]];
    }
    //decode as zero
    return 3;
  }

  int getSpellsKnown(int index, List<dynamic> thisStuff) {
    if (CLASSLIST[index].spellsKnownFormula == null) {
      return (CLASSLIST[index].spellsKnownPerLevel![character.classLevels[index]] -
          thisStuff[1].length) as int;
    }
    //decode as level + 1 and then take away [1].length
    return 3;
  }

  String produceEquipmentOptionDescription(List list) {
    // Initialize an empty string to store the result
    String result = '';

    // Iterate through the list
    for (int i = 0; i < list.length; i++) {
      // Check if the current element is a number
      if (list[i] is num) {
        // Append the current number and string pair to the result string
        result += '${list[i]}x${list[i + 1]}';

        // Skip over the next element (the string)
        i++;
      } else {
        // Append just the current string to the result string
        result += '${list[i]}';
      }

      // If this is not the last element, add a comma and space separator
      if (i != list.length - 1) result += ', ';
    }

    // Return the final formatted string
    return result;
  }
}
